<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>gxnのsite</title>
    <link>https://gxnhxf.com</link>
    <description>personal blog</description>
    
      <item>
        <title>怎样学习</title>
        <link>https://gxnhxf.com/2016/10/18/keep_forword.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/10/18/keep_forword.html</guid>
        <pubDate>2016-10-18 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;学习教材，同伴环境，讲解分享，实践学习，阶段性总结&lt;/p&gt;

&lt;p&gt;舒适区　学习区　恐慌区&lt;/p&gt;

&lt;p&gt;遗忘曲线&lt;/p&gt;

&lt;p&gt;焦虑:能力不匹配，工作量大，拖延习惯
	学习消除焦虑和自我激励&lt;/p&gt;

&lt;p&gt;时间管理&lt;/p&gt;

&lt;p&gt;个人知识管理&lt;/p&gt;

&lt;p&gt;内向，不善言辞负面消极情绪，自我否定　&lt;/p&gt;

&lt;p&gt;阅读写作演讲&lt;/p&gt;

&lt;p&gt;定一个小目标&lt;/p&gt;

&lt;p&gt;1.学习成长曲线理论&lt;br /&gt;
2.学习金字塔理论  &lt;br /&gt;
3.可以练习          &lt;br /&gt;
4.遗忘曲线          &lt;br /&gt;
5.焦虑来源          &lt;br /&gt;
6.自我激励          &lt;br /&gt;
7.意志力提升          &lt;br /&gt;
8.反馈机制          &lt;br /&gt;
9.时间管理          &lt;br /&gt;
10.个人指示管理            &lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>读完《三体》</title>
        <link>https://gxnhxf.com/2016/10/10/Reading_SanTi.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/10/10/Reading_SanTi.html</guid>
        <pubDate>2016-10-10 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;三体&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/santi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　第一次知道三体这本书，源于找工作的时候一家公司的招聘声明——读过《三体》的优先。就是这么抱着好奇，开始读了下来，这是我读的第一本科幻小说，还是读的第一本完整的电子版书籍。没花钱读了刘慈欣的大作，在此对作者表示敬意和歉意。　&lt;/p&gt;

&lt;p&gt;　　看了很多的美国大片，曾经一度认为米国真是太牛了，她的科技发达渗入到生活文化大众娱乐的边边角角，所以才能制造蕴育出如此炫目的科幻作品和天马行空的想象，所以对我们的科技有点失望，看完《三体》之后对我最大的影响就是，改变了一些之前的看法，当然如作者所说的，国内与国外的差别可能就只在于没有形成完整的产业链，不能说孰高孰下，只能说侧重不同，涨姿势了，佩服作者的想象力，这完全比看一部美国科幻大片更能带来更多的思维冲击和享受，而且其中点缀的对人类，对人性，对宇宙的哲理和人类道德的思考非常有佩服，每次毁灭都伴随着对人性与道德的拷问，很能够引发人的思考。宇宙之大，浩瀚无边，太阳系之外，银河系之外，黑暗和光明，为了生存的逃离,威慑,对峙。&lt;/p&gt;

&lt;p&gt;　　《三体》是一幅浩瀚的长卷，把三体时代历史都铺展开，从文革的一个红岸基地为起点，认了经历了对三体的无知所致的恐惧，到了解，对峙，破灭，三体之外呢。后来对小说的作者很好奇，查了下作者出生于那个荒蛮的时代，或许作者也没有经历太多动荡拷问人性的时期，三体之外或许是作者对于大动荡时代的想象，对小说印象最深刻的是对人性，道德，科技，文明的思考和描述，或许是作者对那个时代的思考罢。60后的人都渐渐老去，对那个时代的事情或许人们就再无任何印迹了。　　　&lt;/p&gt;

&lt;p&gt;　　有感的一句是，给岁月以文明，而不是给文明以岁月。当人类科技发展到足以让生命跨越时间，跨越地球超出太阳甚至银河系，真正成为宇宙的独立个体的时候，时间也仅仅只是一个度量，与生命无关，或许只与变化有关。此时人类需要做的是文明续存，但不是去文明以留岁月而苟延残喘。　　　　&lt;/p&gt;

&lt;p&gt;　　黑暗森林，猜疑链，面壁者，执剑人，或许人类就是一个崇拜英雄的族群，在关键时刻需要有少数“英雄”的引领和号召，所谓的独立只是在和平时刻推崇。虽然从小到大学接收的教育都是，人民改变历史，但或许改变历史的关键就在于一小簇人，人民是历史的承载，承载在文化文明代表滚滚向前的潮流，而潮流流向却在于那些执斧开山的人。我信人生来平等，也信人各有其别。&lt;/p&gt;

&lt;p&gt;上网查了下，听说三体要拍电影了，有意思，看了看演员表，感觉导演选角很符合大众眼光，常演将军的演将军，美女帅哥都有，那就就此期待以下，2017年。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>最长递增子序列</title>
        <link>https://gxnhxf.com/2016/08/21/longestIncreaseSequence.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/08/21/longestIncreaseSequence.html</guid>
        <pubDate>2016-08-21 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-07-15 18:34:53
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-21 20:22:09
*/
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
using namespace std;&lt;/cstdlib&gt;&lt;/ctime&gt;&lt;/vector&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;h1 id=&quot;define-max--20&quot;&gt;define MAX  20&lt;/h1&gt;
&lt;p&gt;vector&lt;int&gt; longestIncreasSequesence(vector&lt;int&gt; ints);&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;int main()
{
  //========================数据初始化===================================================&lt;/p&gt;

&lt;p&gt;vector&lt;int&gt; ints;
  srand((unsigned )time(0));
  for (int i = 0; i &amp;lt; MAX; ++i)
  {
    /* code */
    ints.push_back(int(rand()%MAX));
    cout&amp;lt;&amp;lt;ints[i]&amp;lt;&amp;lt;' ';
  }
  cout&amp;lt;&amp;lt;endl;
  //=========================调用算法求解====================================================&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;vector &lt;int&gt; result = longestIncreasSequesence(ints);&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;//========================结果输出显示===================================================&lt;/p&gt;

&lt;p&gt;cout«“最大递增子序列为(长度”«result.size()«”):”«’ ’;
  for (std::vector&lt;int&gt;::reverse_iterator i = result.rbegin(); i != result.rend(); ++i)
  {
   cout&amp;lt;&amp;lt; *i&amp;lt;&amp;lt;&quot; &quot;;
  }
  cout&amp;lt;&amp;lt;endl;
  //=====================================================================================&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;return 0;
}&lt;/p&gt;

&lt;p&gt;vector&lt;int&gt; longestIncreasSequesence(vector&lt;int&gt; ints)
{
  int len=ints.size();
  int c[len];      //c[i] 记录第i号元素 在ints[0:i-1]中以ints[i]为结尾的递增序列结尾的最长子序列的长度&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;int max=1;
  int k;
  int sequence[len]; //记录以元素为递增子序列尾的次小数据的下标,前驱数组下标&lt;/p&gt;

&lt;p&gt;//========================算法的核心===================================================
  c[0]=1;
  sequence[0]=0;&lt;/p&gt;

&lt;p&gt;for (int i = 1; i &amp;lt; len; ++i)
  {
    c[i]=1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int j = 0; j &amp;lt; i; ++j) // 查找c[0:i-1] 在ints[0:i-1] 中满足以ints[i]作为递增结尾并且最长的长度值
{

    if(ints[j]&amp;lt;ints[i] &amp;amp;&amp;amp; c[j]&amp;gt;c[i]-1)
    {  
       
      c[i]=c[j]+1;
      sequence[i]=j;
      if(max &amp;lt; c[i])
      {
        max=c[i];
        k=i;
      }
    }
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;//==================================================================================&lt;/p&gt;

&lt;p&gt;vector&lt;int&gt; seq(1,ints[k]);
  for (int i = 0; i &amp;lt; max-1; ++i)
  {
      k=sequence[k];&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  seq.push_back(ints[k]);   }



 
   return seq ; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>little code</title>
        <link>https://gxnhxf.com/2016/08/18/code.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/08/18/code.html</guid>
        <pubDate>2016-08-18 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;部分刷题代码 &lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;从小到达输出质数因子&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-18 18:16:05
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-21 21:09:25
* 例如输入180 输出 2 2 3 3 5 
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;
&lt;p&gt;#include &lt;cmath&gt;
using namespace std;&lt;/cmath&gt;&lt;/p&gt;

&lt;p&gt;int main(void)
{
    long  intval;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(cin&amp;gt;&amp;gt;intval)
    {
        if(intval&amp;lt;=1)return 0;
        int n=intval;
         for(int i=2;i&amp;lt;=intval;i++)
         {
               while(n%i==0){
                   cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;' ';
                   n/=i;
               }
         }
        cout&amp;lt;&amp;lt;endl;
}

   


return 0; } ``` 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;int&quot;&gt;十六进制字符转int&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-18 16:31:05
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-18 16:31:21
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream-1&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;
&lt;p&gt;#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;&lt;/vector&gt;&lt;/algorithm&gt;&lt;/cctype&gt;&lt;/cstring&gt;&lt;/string&gt;&lt;/p&gt;

&lt;h1 id=&quot;include-cmath&quot;&gt;include &lt;cmath&gt;&lt;/cmath&gt;&lt;/h1&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;int deal(string st)
{
  int result=0;
  reverse(st.begin()+2,st.end());
  st.assign(st.begin()+2,st.end());
  // cout«st«” ”;
  for (int i = 0; i &amp;lt; st.size(); ++i)
  {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;st[i]=toupper(st[i]);
   
if(st[i]&amp;gt;='0'&amp;amp;&amp;amp;st[i]&amp;lt;='9')
  result+= pow(16,i)*(st[i]-'0');
else if(st[i]&amp;gt;='A'&amp;amp;&amp;amp;st[i]&amp;lt;='F')
  result+= pow(16,i)*(st[i]-'A'+10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
  return result;&lt;/p&gt;

&lt;p&gt;}
int main()
{
    string st=”0x2f”;
    vector&lt;string&gt; sts;&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cout&amp;lt;&amp;lt;deal(st);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while(cin»st)
   {
    sts.push_back(st);
   }
   for (int i = 0; i &amp;lt; sts.size(); ++i)
   {
    cout«deal(sts[i])«endl;
    /* code */
   }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;字符串分割&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-18 16:49:00
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-18 16:52:18
* 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
* 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。
*
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream-2&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;
&lt;p&gt;#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int main()
    {
   string st;
    vector&lt;string&gt;sts;
    while(cin&amp;gt;&amp;gt;st)
        {
       sts.push_back(st);
    }
    for(int i=0;i&amp;lt;sts.size();i++)
        {
        if(sts[i].size()&amp;lt;8)
            sts[i]=sts[i]+string(8-sts[i].size(),'0');
        else if(sts[i].size()&amp;gt;8)
        {
            sts.insert(sts.begin()+i+1,string(sts[i].begin()+8,sts[i].end()));
            sts[i].erase(sts[i].begin()+8,sts[i].end());
        }
        cout&amp;lt;&amp;lt;sts[i]&amp;lt;&amp;lt;endl;
    }
    return 0;
}
```&lt;/string&gt;&lt;/vector&gt;&lt;/string&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;简单错误记录&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-18 20:11:21
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-18 20:11:58
*  循环记录 最多只记录8个
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream-3&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;
&lt;p&gt;#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;&lt;/iterator&gt;&lt;/vector&gt;&lt;/string&gt;&lt;/algorithm&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;string simplystr(string st)
{
   string temp;
//   string result;
   st.assign(st.rbegin(),st.rend());&lt;/p&gt;

&lt;p&gt;string::size_type pos=st.find(‘\’);
   temp.assign(st.begin(),st.begin()+pos);&lt;/p&gt;

&lt;p&gt;if(temp.size()&amp;gt;16)
    temp.assign(temp.begin(),temp.begin()+16);&lt;/p&gt;

&lt;p&gt;temp.assign(temp.rbegin(), temp.rend());&lt;/p&gt;

&lt;p&gt;//    result=temp;
//    cout«result;&lt;/p&gt;

&lt;p&gt;return temp;&lt;/p&gt;

&lt;p&gt;}
struct Item
{
   string str;
   int count;
   Item(string s)
   {
       this-&amp;gt;str=s;this-&amp;gt;count=1;
   }
   bool operator == (const Item &amp;amp;a)
   {
    return  (str==a.str);
   }&lt;/p&gt;

&lt;p&gt;} ;
int main()
{
  string st,st1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;Item&amp;gt; sts;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while(cin»st»st1)
  {
    st=simplystr(st);
    st=st+’ ‘+st1;
     Item oneitem(st);
    vector&lt;item&gt;::iterator res=find(sts.begin(),sts.end(),oneitem);&lt;/item&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(sts.end()!=res)
  res-&amp;gt;count++;
else
  sts.push_back(oneitem);

if(sts.size()&amp;gt;8) sts.erase(sts.begin());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
  for (std::vector&lt;item&gt;::iterator i = sts.begin(); i != sts.end(); ++i)
  {
    cout&amp;lt;&lt;i-&gt;str&amp;lt;&amp;lt;' '&amp;lt;&lt;i-&gt;count;
  }&lt;/i-&gt;&lt;/i-&gt;&lt;/item&gt;&lt;/p&gt;

&lt;p&gt;return 0;
}
```&lt;/p&gt;

&lt;h2 id=&quot;int-1&quot;&gt;int 中对应的二进制1的个数&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-19 10:13:55
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-19 12:39:19
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream-4&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;
&lt;p&gt;using namespace std;
int main()
{
    int N=17;
    int number_of_1=0;
    int how_many_bit=0;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int n=N;

while(n)
{
   number_of_1++;
   n=n&amp;amp;(n-1);
}

n=N;
while(n)
{
  how_many_bit++;
  n=n&amp;gt;&amp;gt;1;
}
n=N;
while(--n)
{
  cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; &quot;;
}
cout&amp;lt;&amp;lt;endl;

cout&amp;lt;&amp;lt;&quot;1的个数: &quot;&amp;lt;&amp;lt;number_of_1&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&quot;bit的位数: &quot;&amp;lt;&amp;lt;how_many_bit&amp;lt;&amp;lt;endl;


return 0; } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;k&quot;&gt;链表返回倒数第k个结点&lt;/h2&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-08-19 12:47:51
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-19 12:56:33
&lt;em&gt;/
/&lt;/em&gt;
*
* 理解方式:  1    2   3   4   5   6       N
*          -&amp;gt;|  -&amp;gt;| -&amp;gt;| -&amp;gt;| -&amp;gt;| -&amp;gt;| … -&amp;gt;| -&amp;gt;
&lt;em&gt;/
struct ListNode {
  int val;
  struct ListNode *next;
  ListNode(int x) :
      val(x), next(NULL) {
  }
};
class Solution {
public:
    ListNode&lt;/em&gt; FindKthToTail(ListNode* pListHead, unsigned int k) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ListNode* first =pListHead;
    ListNode* second=pListHead;
    while(k--)
    {
        if(first==NULL)
            return NULL;
        first=first-&amp;gt;next;
    }
    // 此时 first 指向标号为k+1的元素
    //     second 指向标号为1  的元素
    while(first)
    {
        second=second-&amp;gt;next;
        first=first-&amp;gt;next;
    }
    // 此时 first 指向标号为N+1    的元素
    //     second 指向标号为N+1-k  的元素 即倒数第k个元素;
    return second;
    
    
    
} }; ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;httpblogcsdnnetjoylnwangarticledetails6859677&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/joylnwang/article/details/6859677&quot;&gt;和最大的连续子序列 &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于一个包含负值的数字串array[1…n]，要找到他的一个子串array[i…j]（0&amp;lt;=i&amp;lt;=j&amp;lt;=n），
使得在array的所有子串中，array[i…j]的和最大
思路：
首先，对于array[1…n]，如果array[i…j]就是满足和最大的子串，那么对于任何k(i&amp;lt;=k&amp;lt;=j)，
我们有array[i…k]的和大于0。因为如果存在k使得array[i…k]的和小于0，那么我们就有array[k+1…j]
的和大于array[i…j]，这与我们假设的array[i…j]就是array中和最大子串矛盾。
```C++
/*
* @Author: Gxn
* @Date:   2016-08-22 19:29:32
* @Last Modified by:   Gxn
* @Last Modified time: 2016-08-22 19:31:13
*/&lt;/p&gt;

&lt;p&gt;int max_sum_contious_sequence(vector&lt;int&gt; ints)
{
    int result,curmax,left,right,cur_left,cur_right;&lt;/int&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  result=curmax=0;    for (int i = 0; i &amp;lt; ints.size(); ++i)    {

  curmax+=ints[i];
  if(curmax&amp;gt;0)
  {
    right=i;
    if(result&amp;lt;curmax)
    {
      left=cur_left;
      right=cur_right;
    }
  }
  else
  {
    cur_max=0;
    cur_left=cur_right=i+1;
  }    }    return result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return 0;
}
```&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>leetcode 题目总结</title>
        <link>https://gxnhxf.com/2016/08/12/leetcode_summary.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/08/12/leetcode_summary.html</guid>
        <pubDate>2016-08-12 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;线性表部分&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数组、向量&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1. 有序数组删除重复的元素&lt;/h3&gt;
&lt;p&gt;使用一个index=0记录，遍历数组当数组遇到不同的放入array[index++]之中。&lt;/p&gt;

&lt;h3 id=&quot;k&quot;&gt;2. 有序数组如果有重复允许重复最多k次&lt;/h3&gt;
&lt;p&gt;使用一个变量来记录重复的次数  &lt;/p&gt;

&lt;h3 id=&quot;ologn&quot;&gt;3. 查找循环移位的有序数组中的某个数（其中不存在重复的数） 要求O(logn)&lt;/h3&gt;
&lt;p&gt;二分查找 不过查找的前后边界需要做简单处理，分为一下2种情况 &lt;br /&gt;
head |—————————————mid———————&amp;gt;|——————&amp;gt;| tail &lt;br /&gt;
head |———————&amp;gt;|————mid———————————————&amp;gt;| tail &lt;br /&gt;
可以根据head和mid之间的关系来判断数组移动是以上两种情况的哪一种。&lt;br /&gt;
例如对于第一种情况&lt;br /&gt;
如果head&amp;lt;=val&amp;lt;mid 则在[head,mid]之间查找,否则在[mid ,tail]之间找&lt;br /&gt;
对于第二种情况&lt;br /&gt;
如果mid&amp;lt;val&amp;lt;=tail 则在[mid,tail]之间查找，否则在[head,mid]之间找  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 查找循环移位的有序数组中的某个数（其中存在重复的数字）&lt;/h3&gt;
&lt;p&gt;因为存在相同元素，则不能简单的判断head mid tail 的值大小就决定递增顺序，
此时有个简便的方法，当head==mid时候，此时遇到重复，让head继续向前移动既只考察[head+1,tail]之间，继续使用 (3)中的方法。  &lt;/p&gt;

&lt;h3 id=&quot;m-nk-ologmn&quot;&gt;5. 给定两个已经排序好的数组长度分别为m n，找到两者所有元素中第k大的元素 代价O(log(m+n))&lt;/h3&gt;
&lt;p&gt;方法1： 其实直接merge两个数组merge到第k个的时候就结束，代价也不算大，时间O(k) 空间O(k)而已。
方法2： 可以折半查找，连个数组分别是 A[0:m]  B[0:n]分别找到其[k/2]的元素进行比较
如果a&amp;gt;b 则第k大元素在A[0:k/2]和B[k/2+1:n]之间的第k/2大的元素，可以排除掉k/2个元素
如果a&amp;lt;b 同理在A[k/2:m]和B[0,k/2]之间的第k/2大的元素。
如果a==b 那么返回此时的值即是第k大的元素。
### 6. 给定一串数组整数，查找最长递增序列的长度。 &lt;/p&gt;

&lt;h3 id=&quot;two-sum-target-target&quot;&gt;7. two sum 给一个数组一个值target 查找数组中的两个数，其和等于target，返回下标。假设解唯一&lt;/h3&gt;
&lt;p&gt;不能排序，因为返回值的是下标&lt;br /&gt;
暴力方法 O(n^2)&lt;br /&gt;
哈希表方法，map&amp;lt;int,int&amp;gt;mapp ,mapp[值]=下标 复杂度O(n)  &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;8. 对于多个数求和等于某个值的一般都采用先排序然后左右夹逼的方法。&lt;/h3&gt;

&lt;h3 id=&quot;section-5&quot;&gt;9. 删除一个数组中所有的有重复的元素一个不留，方法类似 (1.)&lt;/h3&gt;

&lt;h3 id=&quot;section-6&quot;&gt;10. 积水问题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://img.blog.csdn.net/20131204125216281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2VuZGVuMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot;&gt;!如图&lt;/a&gt;
方法1：找到最高的柱子，然后依次从两边到中间对每个柱子进行计算，peak记录遍历过程中的最大的，然后每次将自己与peak比较如果小于peak那么水量增加peak-自身值。&lt;br /&gt;
方法2：遍历3次数组，前两次找到当前柱子i的左右两侧的最大值和最小值，第三次计算每个柱子上的积水量大小。&lt;/p&gt;

&lt;h3 id=&quot;rotate-image-90&quot;&gt;11. Rotate Image 旋转照片，二维数组表示照片，旋转90度&lt;/h3&gt;
&lt;p&gt;方法：&lt;br /&gt;
      1 2     4 1  变换方法:做沿着反对角线翻转，然后沿着中间翻转1 2    3 2    4 1&lt;br /&gt;
      4 3 =&amp;gt;  3 2                                    	      4 3 =&amp;gt; 4 1 =&amp;gt; 3 2  &lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;12. 大数加法 2.1.17&lt;/h3&gt;
&lt;p&gt;用vector每个元素表示一位 反转用法 rbegin(),注意最后进位。  &lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;13. 爬梯子 2.1.18&lt;/h3&gt;
&lt;p&gt;爬梯子，每次只能爬1个或者2个台阶，如果n个台阶有几种爬法。&lt;br /&gt;
f(n)=f(n-1)+f(n-2) 斐波那契数列&lt;br /&gt;
O(1)的方法是 使用斐波那契数列的通项公式，××××××××××××××××××××××××××××××××××××××× 使用方法。  &lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;14. 格雷码&lt;/h3&gt;
&lt;p&gt;格雷码的每个数和起前后连续两个数分别只有一位不同，格雷码和普通二进制码的转换，Grey=N^(N/2)&lt;br /&gt;
&lt;strong&gt;另外 N&amp;amp;(N-1)表示的是N的二进制将最低位的1变为0的数值。&lt;/strong&gt;  &lt;/p&gt;

&lt;h3 id=&quot;set-matrix-zeros&quot;&gt;15. Set Matrix Zeros&lt;/h3&gt;
&lt;p&gt;二维数组，如果某行某列的数值为0，那么将其对应行列都设置为0，返回处理后的矩阵。&lt;br /&gt;
方法1：m×n的矩阵使用 两个长为m，n的数组记录行是否需要标示为0 列是否标示为0.&lt;br /&gt;
方法2：常数空间，使用第一行、第一列来记录最后利用第一行第一列的数值，来处理整个矩阵   &lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;16. 分糖果问题&lt;/h3&gt;
&lt;p&gt;一排小孩，每个孩子至少一个糖果，年龄大的要比年龄小的多&lt;br /&gt;
使用一个数组来记录每个小孩的糖果数目&lt;br /&gt;
头到尾扫描一遍，遇到递增则在上一个基础上增加一个，遇到比前一个小的则在将其变为1个。  &lt;/p&gt;

&lt;h3 id=&quot;single-number&quot;&gt;17. Single Number&lt;/h3&gt;
&lt;p&gt;找单独数字，一列数中只有一个数字只出现一次，其余均为两次，找出此数字&lt;br /&gt;
方法 使用”^” 位运算。  &lt;/p&gt;

&lt;h3 id=&quot;single-number-2&quot;&gt;18. Single Number 2&lt;/h3&gt;
&lt;p&gt;类似于 17中，此时其余数字均出现三次，那么需要找出此数字。&lt;br /&gt;
可以模拟位的三进制，某个位上出现三那么将其置为0;&lt;br /&gt;
可以设置一个长为n的数组，记录每个位置出现的1的次数，如果是3的倍数将其之为零  &lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;链表&lt;/h2&gt;
&lt;p&gt;单链表   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
    struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x):val(x),next(nullptr){ };
    };
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;1. 大数加法&lt;/h3&gt;
&lt;p&gt;尾部对齐，注意最后的进位  &lt;/p&gt;

&lt;h3 id=&quot;reverse-list-&quot;&gt;2. Reverse List 反转链表&lt;/h3&gt;
&lt;p&gt;头插法   &lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3. 链表去重，类似数组删除重复元素&lt;/h3&gt;
&lt;p&gt;可以采用递归，只需要处理头部第一个，如果相同删除，再迭代处理  &lt;/p&gt;

&lt;h3 id=&quot;rotate-list&quot;&gt;4. Rotate List&lt;/h3&gt;
&lt;p&gt;给定一个k 将list循环移动k步&lt;br /&gt;
首先遍历整个list获取中的list长度len，在此过程中将链表的尾部和头部连接，然后将链表头移动len-k个位置，断开链表。&lt;br /&gt;
注意点：注意当k如果大于len需要考虑，k=k%len；  &lt;/p&gt;

&lt;h3 id=&quot;remove-nth-node-from-end-of-list&quot;&gt;5. Remove Nth Node from end of List&lt;/h3&gt;
&lt;p&gt;定长的问题就是用定长距离指针，一个指针先走N步，然后两个同时走，从而后走的指针能找到倒数第N个的前一个元素，然后执行删除操作即可。  &lt;/p&gt;

&lt;h3 id=&quot;reverse-nodes-in-k-groups----implement&quot;&gt;6. Reverse Nodes in K-groups    &lt;implement&gt;&lt;/implement&gt;&lt;/h3&gt;
&lt;p&gt;每k个nodes 进行反转，最后如果不足k个不反转。&lt;br /&gt;
&lt;strong&gt;递归求解子问题: 先处理前k个然后后边作为一个整体递归处理&lt;/strong&gt;  &lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;7. 判断一个链表是否有环&lt;/h3&gt;
&lt;p&gt;一个快指针一个慢指针，快指针每次走两步，慢指针一次一步。快的最后追上慢的说明有环形。  &lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;8. 链表有环 找环的起始位置&lt;/h3&gt;
&lt;p&gt;类似于 7 中&lt;br /&gt;
假设环的长度为r、链表头到环起始位置长度为l&lt;br /&gt;
当7中快慢指针相遇的时候走的距离分别为s、2s&lt;br /&gt;
t为相遇的位置距离入口的长度。&lt;br /&gt;
此时有：  &lt;/p&gt;

&lt;p&gt;s =l+t 
2s =l+n&lt;em&gt;r+t     =&amp;gt; s= n&lt;/em&gt;r =l + t =&amp;gt; l= n*r - t;&lt;br /&gt;
也就是说 如果在快慢指针相遇的时候在链表头部再放一个慢指针，那么两个慢指针同时向前走，一定能够在环的入口相遇。  &lt;/p&gt;

&lt;h2 id=&quot;section-16&quot;&gt;字符串&lt;/h2&gt;

&lt;h3 id=&quot;kmp&quot;&gt;1. 字串问题，KMP算法&lt;/h3&gt;

&lt;h3 id=&quot;string-to-integer&quot;&gt;2. String to integer&lt;/h3&gt;
&lt;p&gt;需要考虑到string的范围 如果超过integer那么需要特别处理 例如设置&lt;br /&gt;
INT_MAX = 2147483647 INT_MIN = -2147483648&lt;br /&gt;
超出最大最小的范围将其设置为最大最小值。&lt;br /&gt;
另外需要考虑的是’+’、’-‘符号问题  &lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;3. 最大回文字串问题？&lt;/h3&gt;

&lt;h2 id=&quot;section-18&quot;&gt;栈和队列相关的问题需要找几个典型的问题&lt;/h2&gt;

&lt;h2 id=&quot;section-19&quot;&gt;查找和排序问题&lt;/h2&gt;
</description>
      </item>
    
      <item>
        <title>找工作开始了</title>
        <link>https://gxnhxf.com/2016/07/15/findjob.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/07/15/findjob.html</guid>
        <pubDate>2016-07-15 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;开始了&lt;/h2&gt;

&lt;p&gt;现在其实陆陆续续的校招已经开始了，开始进入找工作模式，项目继续进行的同时也要开始完成这些了&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>cpp 复习1</title>
        <link>https://gxnhxf.com/2016/05/31/Cpp_1.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/31/Cpp_1.html</guid>
        <pubDate>2016-05-31 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;class&quot;&gt;class&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;抽象、封装、继承、多态。&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内联函数&lt;/h2&gt;
&lt;p&gt;放在类内部声明的函数为隐式声明的内联函数，也可在类外部使用 inline关键字显式声明一个内联函数。 &lt;br /&gt;
1. 内联声明只是一种对编译器的建议，编译器是否采用内联措施由编译器自己来决定。甚至在汇编阶段或链接阶段，一些没有inline声明的函数编译器也会将它内联展开。 &lt;br /&gt;
2. 编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难。 &lt;br /&gt;
3. 所有中类中定义的函数都默认声明为inline函数，所有我们不用显示地去声明inline。  &lt;br /&gt;
4. 虚函数不允许内联。  &lt;br /&gt;
5. 虽然说模板函数放中头文件中，但它们不一定是内联的。（不是说定义在头文件中的函数都是内联函数） &lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/QG-whz/p/4641479.html&quot;&gt;关于cpp内联函数&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;构造函数的作用就是在对象被创建时利用特定的初始值构造对象，把对象置于某一个初始状态，它在对象被创建的时候由系统自动调用，我们只需要使用默认的构造函数或者自己定义构造函数，而不用管怎么调用的。&lt;br /&gt;
   构造函数的函数名跟类名一样，而且没有返回值。构造函数一般被声明为公有函数，&lt;strong&gt;除非我们不允许某个类生成对象则将它声明为private或protected属性&lt;/strong&gt;
   构造函数也是一个成员函数，所以它可以直接访问类的所有数据成员，可以是内联函数，可以带有形参表，可以带默认的形参值，也可以重载，就是有若干个名字相同但形参个数或者类型不同的构造函数。  &lt;/p&gt;

&lt;h2 id=&quot;httpblogcsdnnetfeiyondarticledetails1807068&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/feiyond/article/details/1807068&quot;&gt;复制构造函数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般的构造函数都是会完成一些成员属性初始化的工作，在对象传递给某一函数之前，对象的一些属性可能已经被改变了，如果在产生对象副本的时候再执行对象的构造函数，那么这个对象的属性又再恢复到原始状态，这并不是我们想要的。&lt;strong&gt;所以在产生对象副本的时候，构造函数不会被执行，被执行的是一个默认的构造函数&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;在C++中，下面三种对象需要拷贝的情况。因此，拷贝构造函数将会被调用。 
1． 一个对象以值传递的方式传入函数体 
2． 一个对象以值传递的方式从函数返回 
3. 一个对象需要通过另外一个对象进行初始化 
如果一个类中有指针成员，使用缺省的复制构造函数初始化对象就会出现问题。为了说明存在的问题，我们假定对象A与对象B是相同的类，有一个指针成员，指向对象C。当用对象B初始化对象A时，缺省的复制构造函数将B中每一个成员的值复制到A的对应的成员当中，但并没有复制对象C。也就是说，对象A和对象B中的指针成员均指向对象C，实际上，我们希望对象C也被复制，得到C的对象副本D。否则，当对象A和B销毁时，会对对象C的内存区重复释放，而导致错误。  &lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;析构函数&lt;/h2&gt;

&lt;p&gt;析构函数和构造函数的作用是相反的，它会在对象被删除之前做一些清理工作。&lt;strong&gt;析构函数是在对象要被删除时由系统自动调用的&lt;/strong&gt;,它执行完后对象就消失了，分配的内存空间也释放了。&lt;br /&gt;
 析构函数是类的一个公有函数成员，它的名称是在类名前加“~”形成，不能有返回值，注意，&lt;strong&gt;它和构造函数不同的是它不能有任何形参&lt;/strong&gt;。如果没有定义析构函数系统也会自动生成一个默认析构函数，&lt;strong&gt;默认析构函数也不会做任何工作&lt;/strong&gt;。   &lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;向前引用声明&lt;/h2&gt;
&lt;p&gt;C++中，要使用一个类必须在使用前已经声明了该类，但是两个类互相包含时就肯定有一个类在定义之前就被引用了，这时候怎么办呢？就要用到前向引用声明了。前向引用声明是在引用没有定义的类之前对该类进行声明，这只是为程序声明一个代表该类的标识符，类的具体定义可以在程序的其他地方，简单说，就是声明下这个标识符是个类，它的定义你可以在别的地方找到。   &lt;/p&gt;

&lt;p&gt;比如，类A的公有成员函数f的形参是类B的对象，同时类B的公有成员函数g的形参是类A的对象，这时就必须使用前向引用声明：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
       class B;  //**前向引用声明**
       class A
       {  
       public:
              void f(B b);
       };
       class B
       {  
       public:
              void g(A a);
       };
&lt;/code&gt; &lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;类模版&lt;/h2&gt;
&lt;p&gt;类模板就是为类声明一种模板，使得类中的某些数据成员，或某些成员函数的参数，又或者是某些成员函数的返回值可以取任意的数据类型，包括基本数据类型和自定义数据类型。&lt;br /&gt;
类模版使得：
1. 类的数据成员
2. 成员函数的参数
3. 函数返回值
可以取任意类型。
&lt;code&gt;C++ 
template   未完待续。 
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;静态成员变量&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;使用示例&lt;/h3&gt;
&lt;p&gt;```C++
        #include &lt;iostream&gt;
        using namespace std;
        class CStudent         // 学生类的声明
        {
        public: 
                  CStudent(int nID)    { m_nID = nID; m_nCount++; }       // 构造函数
                  CStudent(CStudent &amp;amp;s);                                 // 拷贝构造函数
                  int GetID(){ return m_nID;}
                  void GetCount()       { cout&amp;lt;&amp;lt;&quot; 学生人数：&quot;&amp;lt;&amp;lt;m_nCount&amp;lt;&amp;lt;endl; } // 输出静态数据成员
        private: 
                  int m_nID;
                  static int m_nCount;                                  // 静态数据成员的引用性说明
        };
       CStudent::CStudent(CStudent &amp;amp;s)
       { 
                  m_nID = s.m_nID;
                  m_nCount ++;
       }&lt;/iostream&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   int CStudent::m_nCount=0;                                       // 静态数据成员的定义性说明及初始化
   int main() 
   { 
              CStudent A(6);             // 定义对象A
              cout&amp;lt;&amp;lt;&quot;学生A,&quot;&amp;lt;&amp;lt;A.GetID();
              A.GetCount();               // 输出此时学生个数
              CStudent B(A);            // 定义对象B，并用A初始化B
              cout&amp;lt;&amp;lt;&quot;学生B,&quot;&amp;lt;&amp;lt;B.GetID(); // 输出此时学生个数
              B.GetCount(); 
              return 0;
   } ```    当然学生的学号不可能一样，这里只是举个例子。类CStudent的静态数据成员m_nCount用来给学生人数计数，定义一个新的学生对象，它的值就加1。这里初始化的时候要注意，必须用类名来引用，还有就是此数据成员的访问控制属性，这里m_nCount声明为私有类型，初始化时可以直接访问，但是在主函数内就不能直接访问了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;静态成员函数访问私有非静态变量&lt;/h4&gt;
&lt;p&gt;静态成员函数跟静态数据成员一样，也是由类的所有对象所共有，由他们共同维护和使用。声明时前面也要加static关键字，比如，static void fun(void);。我们可以通过类名或对象名调用公有类型的静态成员函数，而非静态成员函数只能由对象名调用。
  &lt;strong&gt;静态成员函数可以访问该类的静态数据成员和其他静态成员函数，如果要访问非静态数据成员，则必须将对象作为参数传递进去，然后通过传进去的对象名来访问.&lt;/strong&gt;
例如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
   class A
       {
       public:
                 static void f(A a);
       private:
                 int x;
       };
       void A::f(A a)
       {
                cout&amp;lt;&amp;lt;x;     //对x的引用是错误的
                cout&amp;lt;&amp;lt;a.x;  //正确
       }
&lt;/code&gt;
   静态成员的好处就是内存中只有一份拷贝，可以直接通过类名访问
也可以改为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
   class A
    {
          public:
                 static void f(){return x;};//静态成员函数访问静态成员变量。
          private:
                 static int x;
    };
    int main()
    {
        A a;
        cout&amp;lt;&amp;lt;a.f()&amp;lt;&amp;lt;endl; 
        cout&amp;lt;&amp;lt;A::f()&amp;lt;&amp;lt;endl;//同上一句有相同的功能。
    }
&lt;/code&gt; 
&lt;strong&gt;主函数中就可以通过类名或对象名调用静态成员函数。静态成员的好处就是内存中只有一份拷贝，可以直接通过类名访问&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;友元&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;C++
   class A
   {
   public:
              int get(){return x;};
    private:  int x ;
   };
   class B
   {
     public:
             void setx();
     private: 
            A a;
   };
   void B::setx()
   {
    a.x=y;// 这样的个用法是不正确的。
   }
&lt;/code&gt;
如何实现B成员函数直接访问A的私有成员变量，C++提供了友元。
原则上尽量少使用友元。&lt;/p&gt;

&lt;p&gt;在一个类中声明友元的方式是：
关键字friend把普通函数、
其他类的成员函数、
其他类声明为此类的友元，
用friend声明的元素就可以访问此类的私有数据。
如果友元是普通函数或是类的成员函数就叫做友元函数，如果友元是一个类则叫做友元类，友元类的所有成员函数均为友元函数。&lt;/p&gt;

&lt;p&gt;友元关系是单向的,不能够传递，如果B是A的友元类（类B的成员函数可以访问类A对象的私有成员），C是B的友元类，C和A没有友元关系&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;常成员函数&lt;/h2&gt;
&lt;p&gt;类的常成员函数&lt;/p&gt;

&lt;p&gt;类中用const声明的成员函数就是常成员函数。
常成员函数的声明形式为：类型说明符 函数名(参数表) const;。
注意：
a.常成员函数在声明和实现时都要带const关键字；  &lt;br /&gt;
b.成员函数不能修改对象的数据成员，也不能访问类中没有用const声明的非常成员函数；     &lt;br /&gt;
c.常对象只能调用它的常成员函数，不能调用其他的普通成员函数；    &lt;br /&gt;
d.&lt;strong&gt;const关键字可以被用于参与对重载函数的区分&lt;/strong&gt;，    &lt;br /&gt;
比如，如果有两个这样声明的函数：void fun(); void fun() const;，则它们是重载函数。  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
     #include&amp;lt;iostream&amp;gt;
        using namespace std;
        class R
        { 
        public:
                    R(int r1, int r2)    { R1=r1; R2=r2; }
                    void print();
                    void print() const;
        private:
                    int R1,R2;
        };
        void R::print()
        { 
                   cout&amp;lt;&amp;lt;R1&amp;lt;&amp;lt;&quot;:&quot;&amp;lt;&amp;lt;R2&amp;lt;&amp;lt;endl;
        }
        void R::print() const
        { 
                  cout&amp;lt;&amp;lt;R1&amp;lt;&amp;lt;&quot;;&quot;&amp;lt;&amp;lt;R2&amp;lt;&amp;lt;endl;
        }
        int main()
        { 
                 R a(5,4);
                 a.print(); //调用void print()
                 const R b(20,52);  
                 b.print(); //调用void print() const
                 return 0;
        }
&lt;/code&gt;
上面的R类中声明了两个同名函数print，第二个是常成员函数。
在main函数中定义了两个对象a和b，b是常对象，通过a调用的是没有用const声明的函数，而通过b调用的是用const声明的常成员函数。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;类的函数指针和成员变量指针&lt;/h2&gt;

&lt;p&gt;声明指向非静态成员的指针的语法形式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   类型说明符 类名::*指针名;                    // 指向公有数据成员的指针
   类型说明符 (类名::*指针名)(形参表);          // 指向公有成员函数的指针
   int CStudent::m_nCount = 0;   // 静态数据成员初始化
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-12&quot;&gt;类的继承&lt;/h2&gt;
&lt;p&gt;class 类名  ：继承方式1 父类名称1 ,   继承方式2 父类名称2 
class Child : public   Parent1    ,   private    Parent2
{
    public:
           Child();
           ~Child();
};&lt;/p&gt;

&lt;p&gt;派生类从基类继承时首先就是吸收基类成员，将基类成员中&lt;strong&gt;除了构造函数和析构函数&lt;/strong&gt;外的所有其他成员全部接收。
这里要注意，基类的构造函数和析构函数都不能被派生类继承。
派生类成员的“同名覆盖”:一旦我们在派生类中声明了一个和基类某个成员同名的成员，那么派生类这个成员就会覆盖外层的同名成员。参数列表完全相同时候才是同名覆盖不然就是重载了。&lt;/p&gt;

&lt;h3 id=&quot;public--&quot;&gt;public  继承&lt;/h3&gt;
&lt;p&gt;派生类的继承方式为public，即公有继承时，对基类中的公有成员和保护成员的访问属性都不变，而对基类的私有成员则不能访问。
### private 继承
在私有继承方式中，基类的公有成员和保护成员被派生类继承后变成派生类的私有成员，而基类的私有成员在派生类中不能访问
private继承 在子类之外不能够访问基类的公有成员和保护成员。&lt;/p&gt;

&lt;p&gt;私有继承&lt;strong&gt;使得基类的成员在其派生类后续的派生中不能再被访问&lt;/strong&gt;，中止了基类成员继续向下派生，这对代码的复用性没有好处，所以一般很少使用私有继承方式。&lt;/p&gt;

&lt;p&gt;```C++
/*
* @Author: Gxn
* @Date:   2016-06-01 09:58:17
* @Last Modified by:   Gxn
* @Last Modified time: 2016-06-02 10:46:54
*/&lt;/p&gt;

&lt;h1 id=&quot;include-iostream&quot;&gt;include &lt;iostream&gt;&lt;/iostream&gt;&lt;/h1&gt;

&lt;p&gt;using namespace std;
class base
{
public:
  base(){public_var=10;private_var=100;cout«“base 构造函数.”«endl;};
  ~base(){cout«“base 析构函数.”«endl;};
  int public_var;//public 变量但是在子类中不能被直接访问。
  int getx(){return private_var;}
private:
   int private_var;// 对base类的private继承，此成员变量将不能在子类被访问，也就是说此成员完全对子类隐藏了。&lt;br /&gt;
};&lt;/p&gt;

&lt;p&gt;class child:private base
{
public:
  child(){x=2;a=3;cout«“child 构造函数”«endl;cout«“this is member of base:”«public_var«endl;};
  ~child(){cout«“child 析构函数”«endl;};
    int a;
    int getx();
    int getbase_public_var() {return public_var; };
protected:
private: 
 static int x;
};
int  child::x=9;
int child::getx()
{
  return base::getx();//由于同名覆盖 基类中含有getx()，通过这种方式可以实现对基类的修改和扩展。
}&lt;/p&gt;

&lt;p&gt;int main(){
     child te2;
    cout« te2.getx()«endl;
    cout«te2.a«endl;
    cout«te2.getbase_public_var()«endl;
    return 0;
}
```
输出结果： &lt;br /&gt;
    base 构造函数.
    child 构造函数
    this is member of base:10
    100
    3
    10
    child 析构函数
    base 析构函数.
    [Finished in 2.7s]&lt;/p&gt;

&lt;p&gt;可以看到，面向对象的封装性，base类和child类的外部接口可以相同如getx()函数，只要保持外部接口不变内部数据结构调整，则对外接是透明的。
这体现了面向对象设计的可维护性和可扩展性。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;派生类构造函数&lt;/h2&gt;
&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
       #include &amp;lt;iostream&amp;gt;
       using namespace std;
       class Base1          // 基类Base1，只有默认构造函数
       {
       public:
                 Base1()         { cout&amp;lt;&amp;lt;&quot;Base1 construct&quot;&amp;lt;&amp;lt;endl; }
       };
       class Base2          // 基类Base2，只有带参数的构造函数
       {
       public:
                 Base2(int x)    { cout&amp;lt;&amp;lt;&quot;Base2 construct &quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; }
       };
       class Base3          // 基类Base3，只有带参数的构造函数
       {
       public:
                Base3(int y)    { cout&amp;lt;&amp;lt;&quot;Base3 construct &quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; }
       };
       class Child : public Base2, public Base1, public Base3   // 派生类Child
       {
       public:
                Child(int i,int j,int k,int m):Base2(i),b3(j),b2(k),Base3(m)    { }
       private:             // 派生类的内嵌对象成员
                Base1 b1;
                Base2 b2;
                Base3 b3;
       };
       int main()
       {
                Child child(3,4,5,6);
                return 0;
       }
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;赋值兼容规则&lt;/h2&gt;
&lt;p&gt;类Base为基类，类Child0为Base的公有派生类，类Child1为类Child0的公有派生类。三个类中都定义了成员函数show()。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++
       #include &amp;lt;iostream&amp;gt;
       using namespace std;
       class Base           // 基类Base的声明
       {
       public:
                  void show()    { cout &amp;lt;&amp;lt; &quot;Base::show()&quot; &amp;lt;&amp;lt; endl; }      // 公有成员函数show
       };
       class Child0 : public Base     // 类Base的公有派生类Child0的声明
       {
       public:
                 void show()    { cout &amp;lt;&amp;lt; &quot;Child0::show()&quot; &amp;lt;&amp;lt; endl; }    // 公有成员函数show
       };
       class Child1 : public Child0   // 类Child0的公有派生类Child1的声明
       {
       public:
                 void show()    { cout &amp;lt;&amp;lt; &quot;Child1::show()&quot; &amp;lt;&amp;lt; endl; }    // 公有成员函数show
       };
       void CallShow(Base *pBase)     // 一般函数，参数为基类指针
       {
                pBase-&amp;gt;show();
       }
       int main()
       {
               Base base;                 // 声明Base类的对象
               Base *pBase;             // 声明Base类的指针
               Child0 ch0;                 // 声明Child0类的对象
               Child1 ch1;                 // 声明Child1类的对象
               pBase = &amp;amp;base;        // 将Base类对象base的地址赋值给Base类指针pBase
               CallShow(pBase);
               pBase = &amp;amp;ch0;            // 将Child0类对象ch0的地址赋值给Base类指针pBase
               CallShow(pBase);
               pBase = &amp;amp;ch1;            // 将Child1类对象ch1的地址赋值给Base类指针pBase
               CallShow(pBase);
               return 0;
       }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;即使派生类对象代替了基类对象，它也只能产生基类的功能，自己的新功能无法体现。
要想在代替以后同样能够实现自己的功能,需要用到多态。&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;多态&lt;/h2&gt;
&lt;p&gt;多态性有四种类型：重载多态、强制多态、参数多态和包含多态。
. ::  sizeof ?. 不能重载，其余运算符均可以重载。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;虚函数的多态&lt;/h3&gt;
&lt;p&gt;这个动态绑定过程在运行时完成，实现了运行时的多态。
这样通过基类指针就可以访问指向的不同派生类的对象的成员，这在不仅使代码整齐简洁，而且也大大提高了开发效率。&lt;/p&gt;

&lt;p&gt;```C++
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class Base
{
public:
  virtual void show(){cout«“base show”«endl;} // 这里基类中定义了一个虚函数.
};&lt;/p&gt;

&lt;p&gt;class child:public Base
{
public:
  void show(){cout«“child show”«endl;}
};&lt;/p&gt;

&lt;p&gt;class child1 :public child
{
public:
  void show(){cout«“child1 show”«endl;}
};&lt;/p&gt;

&lt;p&gt;void Callbase(Base *p)
{
  p-&amp;gt;show();
}&lt;/p&gt;

&lt;p&gt;int main()
{
     Base base;
     child ch;
     child1 ch1;
     Callbase(&amp;amp;base);
     Callbase(&amp;amp;ch);
     Callbase(&amp;amp;ch1);
    return 0;
}&lt;/p&gt;

&lt;p&gt;/&lt;strong&gt;**
base show   输出结果分别调用的是各个类自己成员函数,而不是基类的函数.
child show
child1 show
**&lt;/strong&gt;/
```&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;抽象类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;抽象类可以为某个类族提供统一的操作接口&lt;/strong&gt;。外部可以透明的使用抽象类的统一接口，而不需要知道到底是调用的抽象类的哪个派生类的成员函数。
其实这些也可以通过在基类中定义虚函数来实现，但&lt;strong&gt;抽象类&lt;/strong&gt;跟一般类不同的是，它&lt;strong&gt;使用纯虚函数&lt;/strong&gt;，&lt;strong&gt;不需要定义纯虚函数的实现，而且抽象类不能实例化&lt;/strong&gt;，即不能定义抽象类的对象，只能从它继承出非抽象派生类再实例化&lt;/p&gt;

&lt;p&gt;```C++
#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;class Base  //定义了一个抽象类
{
public:
  virtual void show()=0; // 声明纯虚函数
};&lt;/p&gt;

&lt;p&gt;class child:public Base
{
public:
  void show(){cout«“child show”«endl;}
};&lt;/p&gt;

&lt;p&gt;class child1 :public child
{
public:
  void show(){cout«“child1 show”«endl;}
};&lt;/p&gt;

&lt;p&gt;void Callbase(Base *p)
{
  p-&amp;gt;show();
}&lt;/p&gt;

&lt;p&gt;int main()
{
     Base base;
     child ch;
     child1 ch1;
     Callbase(&amp;amp;base);
     Callbase(&amp;amp;ch);
     Callbase(&amp;amp;ch1);
    return 0;
}&lt;/p&gt;

&lt;p&gt;/&lt;strong&gt;**
 In function ‘int main()’:
37:11: error: cannot declare variable ‘base’ to be of abstract type ‘Base’ 抽象类不能够被实例化
12:7: note:   because the following virtual functions are pure within ‘Base’:
15:15: note:  virtual void Base::show()  纯虚函数不能够被直接调用
**&lt;/strong&gt;/
```&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;异常&lt;/h2&gt;
&lt;p&gt;try catch throw&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>vim usage</title>
        <link>https://gxnhxf.com/2016/05/30/vimnote.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/30/vimnote.html</guid>
        <pubDate>2016-05-30 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;键&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;键&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;\｜and 0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示行首；&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;K&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;自动在man page中查阅光标处手册对应的关键字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;U&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;恢复当前行的修改&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;u&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;撤销命令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;“a~z&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在使用y/p/d之前，使用”a~z 表示指定指令缓存器,例如 “ayy 表示复制当前行到指令缓存器ａ中，这样可以复制当前文件的一行到另外一个打开的文件中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;H&amp;amp;L&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;回到当前视图的顶部,回到当前视图的底部&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;F&amp;amp;f [word]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;光标前\后查找word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;合并两行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;(/)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;段首/尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;%&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;括号配对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ctrl+f/b/e/y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;翻页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;qx/q&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;宏录制/退出录制&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
      </item>
    
      <item>
        <title>RPL note</title>
        <link>https://gxnhxf.com/2016/05/20/RPL.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/20/RPL.html</guid>
        <pubDate>2016-05-20 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;DIO(DODAG Information Object) DODAG信息对象   &lt;br /&gt;
DAO(Destination Advertisement Object) 目的地通告   &lt;br /&gt;
DIS(DODAG Information Solicitation) 请求信息    &lt;/p&gt;

&lt;h2 id=&quot;overview-what-is-rpl&quot;&gt;Overview what is RPL?&lt;/h2&gt;
&lt;p&gt;RPL is a distance vector routing protocol for LLNs that makes use of IPv6.
基于IPV6的距离向量路由协议。
通过计算节点与根节点之间的关系来避免路由环路。
定义4种类型的控制消息：来维护路由和节点之间信息交换。另外一个重要的事情是维护网络拓扑。    &lt;/p&gt;

&lt;p&gt;6LoWPAN协议协议架构图：     &lt;br /&gt;
&lt;img src=&quot;/public/img/pic/rpl/6LoWPAN协议体系架构.png&quot; alt=&quot;6LoWPAN协议体系架构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rpl-instance&quot;&gt;RPL instance&lt;/h3&gt;
&lt;p&gt;一个DODAG由一个RPLinstanceID 和一个DODAGID共同唯一确定，一个RPLinstance 可以包含多个DODAG。RPL路由协议通过4个值，RPLinstanceID和DODAGID、DODAGversionNunber和Rank来描述。   &lt;/p&gt;

&lt;p&gt;RPL DODAGinstance:&lt;br /&gt;
&lt;img src=&quot;/public/img/pic/rpl/RPLinstance.png&quot; alt=&quot;RPLinstance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RPL DODAGversion:&lt;br /&gt;
&lt;img src=&quot;/public/img/pic/rpl/dodagversion.png&quot; alt=&quot;dodagversion&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rpl-upward-routing-&quot;&gt;RPL Upward Routing 上行路由的形成&lt;/h2&gt;
&lt;p&gt;DIO mesaage structure  &amp;amp; Construction Topologies
DIO消息中包含的信息：&lt;/p&gt;

&lt;h3 id=&quot;dio-message-structure&quot;&gt;DIO message structure&lt;/h3&gt;

&lt;h3 id=&quot;construction-topologies-&quot;&gt;Construction Topologies 构建拓扑过程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;开启根节点开始发送DIO消息&lt;/li&gt;
  &lt;li&gt;接收到消息的节点执行算法选择一个父亲节点。（选择算法是基于目标函数的一些度量和限制）&lt;/li&gt;
  &lt;li&gt;每个节点计算自己的Rank值，更新完rank值之后发送DIO消息给所有的邻居节点。&lt;/li&gt;
  &lt;li&gt;重复2、3步骤，直到DIO消息到达叶子节点或者所有节点都加入网络。
&lt;img src=&quot;/public/img/pic/rpl/construction.png&quot; alt=&quot;构建路由过程&quot; /&gt;   &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简而言之：拓扑首先从根节点开始根节点发送DIO消息给邻居，邻居收到之后会回复DAO目的地通告信息，然后邻居再发DIO给通知邻居的邻居;需要知道的是节点也可以主动请求发送DIS消息，然后被请求节点会发送DIO消息，节点回复DAO消息，然后节点就加入被请求节点的拓扑中，这时候被请求节点还需要逐级的上报DAO消息，给其父节点、父节点的父亲等，直到根节点。还有就是节点计算自己的Rank值。  &lt;br /&gt;
&lt;strong&gt;节点 根据收到的DIO消息，选择父亲节点，添加路由，广播图信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了保证DODAG的唯一性：
1. 每个DODAG需要一个RPL实例ID，标示一个独立的DADOG。
2. DADOGID 是根节点的IPV6地址。
3. DODAG version number：每次DODAG重构的时候将会自增1。
为了实现RPL动态的调整发送DIO消息的频率，两个值需要被使用，最大时间间隔Tmin和最小时间间隔 Tmax。&lt;/p&gt;

&lt;h2 id=&quot;routing-loops-&quot;&gt;Routing Loops 路由环路&lt;/h2&gt;
&lt;p&gt;为了解决路由环路的问题，使用两种机制，&lt;strong&gt;避免机制&lt;/strong&gt;和 &lt;strong&gt;探测机制&lt;/strong&gt;    &lt;/p&gt;

&lt;h3 id=&quot;avoidance-mechanisms-&quot;&gt;Avoidance Mechanisms 如何避免环路&lt;/h3&gt;
&lt;p&gt;RPL节点不会处理rank值比自己小的节点的DIO消息，也就是说不允许节点选择比自己rank值小的节点作为父亲节点。
还有就是节点对DODAG version的通告有限制？？？？？？没太懂。&lt;/p&gt;

&lt;h3 id=&quot;detection-mechanisms-&quot;&gt;Detection Mechanisms 如何检测到环路&lt;/h3&gt;
&lt;p&gt;使用发送数据包的额外信息。？？
放置一个RPL数据包信息在IPV6的option field中，每条都进行检测并更新。？？
在RPL的数据包中，有5个方面的控制信息：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要数据包上行还是下行需要表明 &lt;strong&gt;设置了一个bit标识&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果检测到Rank值不匹配，那么需要被报告。&lt;/li&gt;
  &lt;li&gt;report a error field by a child node&lt;/li&gt;
  &lt;li&gt;需要包含发送方的rank值&lt;/li&gt;
  &lt;li&gt;包含RPL instance ID&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;rpl-metrics-rpl&quot;&gt;RPL METRICS RPL度量&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;节点能量消耗&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EXT
PRR(packet reception rate 包接比例)： 接收包个数/发送包的个数。
EXT= 1 / (PRR上行 * PRR下行)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;下行路由&lt;/h2&gt;

&lt;h3 id=&quot;dao-message-structure&quot;&gt;DAO Message Structure&lt;/h3&gt;

&lt;h2 id=&quot;section-1&quot;&gt;本地修复和全局修复&lt;/h2&gt;
&lt;p&gt;当检测到 &lt;strong&gt;存在环路&lt;/strong&gt;或者 &lt;strong&gt;邻居节点失效&lt;/strong&gt;之后将会触发本地修复，&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/public/files/无线传感器网络的RPL路由协议研究_朱琳.pdf&quot;&gt;无线传感器网络的RPL路由协议研究_朱琳.pdf&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;/public/files/NET-2011-07-1_09.pdf&quot;&gt;RPL: IPv6 Routing Protocol for Low Power and Lossy Networks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于分片的链接 其中有图已经截取
http://www.tcpipguide.com/free/t_IPv6DatagramSizeMaximumTransmissionUnitMTUFragment-4.htm
ipv6 扩展头部
http://www.cisco.com/en/US/technologies/tk648/tk872/technologies_white_paper0900aecd8054d37d.html&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Network Layer</title>
        <link>https://gxnhxf.com/2016/05/17/network3.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/17/network3.html</guid>
        <pubDate>2016-05-17 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;网络层&lt;/h1&gt;

&lt;h2 id=&quot;ipv4--ipv6&quot;&gt;ipv4 &amp;amp; ipv6&lt;/h2&gt;

&lt;h3 id=&quot;ipv4&quot;&gt;ipv4&lt;/h3&gt;

&lt;h4 id=&quot;ipv4-1&quot;&gt;关于ipv4地址&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ipv4地址32位 一般使用点分10进制显示，增强可读性。&lt;/li&gt;
  &lt;li&gt;网络地址块的分配：一个组织可以申请一块地址，一般要求此块地址要是连续的，个数是2的幂次，并且其实地址要能够被个数整除。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一般块地址起始地址不分配给任何设备&lt;/strong&gt;，它用作向世界其他部分表示该组织的网络地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ipv4-2&quot;&gt;ipv4数据报格式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://7xntdm.com1.z0.glb.clouddn.com/IPformat.png&quot; alt=&quot;&quot; /&gt;
### ipv6&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;关于分片&lt;/h3&gt;

&lt;h3 id=&quot;section-2&quot;&gt;路由算法&lt;/h3&gt;
&lt;p&gt;静态路由 or 动态路由 &lt;br /&gt;
1. 静态路由:手工配置、路由更新慢、优先级高
2. 动态路由:定期更新、及时响应链路费用或网络拓扑变化.&lt;/p&gt;

&lt;p&gt;每个路由表可以存储全局信息也可以存储局部信息
1. 全局信息：所有路由器掌握完整的网络拓扑和链路费用信息，have a big picture 可能路由表比较大。  &lt;br /&gt;
2. 局部信息：路由器只掌握物理相连的邻居以及链路费用，邻居间信息交换,运算的迭代过程。   &lt;/p&gt;

&lt;p&gt;路由算法基本类型：&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;链路状态路由算法&lt;/h4&gt;

&lt;h4 id=&quot;section-4&quot;&gt;距离矢量路由算法&lt;/h4&gt;
&lt;p&gt;核心思想；每个路由表只包含自己到周围邻居的距离向量DV，然后不定期的向周围邻居发送自己的DV，邻居收到了之后更新自己的路由表。属于分布式的更新，每当局部路由链路费用改变时候将会通告邻居。&lt;/p&gt;

&lt;p&gt;这里更新DV时候可能存在一个无穷计数问题，采用“毒性逆转”方法可以解决某些情况下的问题，但是对于复杂网络并不能完全解决。
这时候需要定义一个最大的度量，比如定义最大跳数为15条，16条跳表示无穷大。&lt;/p&gt;

&lt;p&gt;#### &lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Data Link Layer</title>
        <link>https://gxnhxf.com/2016/05/13/network2.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/13/network2.html</guid>
        <pubDate>2016-05-13 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;数据链路层&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;数据链路层&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;LLC 数据链路控制层&lt;/td&gt;
      &lt;td&gt;LLC：主要功能 成帧、流量控制、差错控制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAC 介质访问控制层&lt;/td&gt;
      &lt;td&gt;MAC：负责多路访问的控制&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;流量控制：是一系列的程序用来控制发送向接收方发送数据的数量。 &lt;br /&gt;
差错控制：是基于自动重复请求ARQ，检测到差错即需要按照一定规则重传数据帧。  &lt;br /&gt;
常见的流量控制：最基本的停等协议、GBN goback N ARQ、选择性重复的ARQ &lt;br /&gt;
捎带技术；其中前三个数据都是单方向的由Sender-&amp;gt;receiver;捎带技术是双向的数据传输。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;最简单的停等协议： 发数据、等ACK 、ACK序列号为0101交错的序列。       &lt;/p&gt;

&lt;p&gt;GBN协议：m位的序列号，发送窗口小于等于2^m-1 序列号为mod(2^m);发送窗口不能大于2^m因为可能会导致发送2^m个帧后，Receiver 返回ACK丢失，Sender要回退滑动窗口N个，重发又从窗口的第一个数据帧开始向reveiver发送数据帧此时的序列号为0，但是这对于接收者其实是一个需要丢弃的副本，但是接收者需要接收序列号为0的数据，所以识别错误。    &lt;/p&gt;

&lt;p&gt;选择性重复ARQ: 接收窗口为2^(m-1),接收时候不是按顺序来接收，接收方也存在一个接收窗口，接收窗口和发送窗口小于2^(m-1),因为如果大于2^m，那么接收方和发送方窗口之和将会跨越2^m序列号范围，会导致错误。
选择性ARQ的接收窗口的逻辑比GBN复杂了些：S：1 2 3 4 5 ；R： 2 3 4 5 ;R没有收到1，当收到2时会发NAK1要求重发1 收到3的时候就不会再继续发NAK1，也就是不用每次重复的发送没收到数据帧的NAK,为了减少网络拥堵。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GBN&lt;/th&gt;
      &lt;th&gt;选择性重复ARQ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;窗口最大2^m-1&lt;/td&gt;
      &lt;td&gt;最大窗口2^(m-1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;定时器只需要一个，只需记录最先发送的数据帧收ACK是否超时&lt;/td&gt;
      &lt;td&gt;定时器需要多个，因为接收窗口数据帧有多个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;不发NAK超时自动重传&lt;/td&gt;
      &lt;td&gt;如果没有收到需要发NAK&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;捎带技术 :
双向数据传输，数据不止是S-&amp;gt;R R-&amp;gt;S  ACK可以插入到数据帧中 &lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;多路复用&lt;/h2&gt;
&lt;p&gt;常见多路复用技术:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;随机访问&lt;/th&gt;
      &lt;th&gt;受控访问&lt;/th&gt;
      &lt;th&gt;通道协议&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ALOHA/CSMA/CSMA-CD/CSMA-CA&lt;/td&gt;
      &lt;td&gt;预约、轮询、令牌环&lt;/td&gt;
      &lt;td&gt;FDMA、TDMA、CDMA&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;aloha&quot;&gt;ALOHA&lt;/h3&gt;
&lt;p&gt;ALOHA 有数据即发送，发送中遇到冲突即回退等待，等待方式：二进制指数回退。
纯ALOHA：脆弱时间为2*T (T:为一帧平均传输时间), 即在在发送之后2T时间之内数据可能会产生冲突。
时隙ALOHA: 脆弱时间为T，每个发送时间为T。&lt;/p&gt;

&lt;h3 id=&quot;csma&quot;&gt;CSMA&lt;/h3&gt;
&lt;p&gt;载波侦听多路访问, 发送之前需要侦听一下链路中是否有数据。&lt;/p&gt;

&lt;h3 id=&quot;csma-cd&quot;&gt;CSMA-CD&lt;/h3&gt;
&lt;p&gt;需要要求帧的最小长度限制。 &lt;br /&gt;
Tf为帧传输时间，Tp为帧的最大传播时延，其中需要Tf&amp;gt;2Tp; &lt;br /&gt;
因为 从S-&amp;gt;R 的数据帧传播的时间为Tp,由于传播时延，R未检测到数据
即发送数据此时当S接收到R发送的数据时候经历时间为2Tp。 &lt;br /&gt;
需要保证经过2*Tp时间此时S还在发送此帧的数据尚未结束，因为，如果在此帧数据的最后一位前发送如果没有检测到冲突，那么一旦整个帧发完了，同时冲突了，会导致S无法保存副本，而此时R收到为已经被冲突污染的帧。   &lt;/p&gt;

&lt;h3 id=&quot;csma-ca&quot;&gt;CSMA-CA&lt;/h3&gt;
&lt;p&gt;带冲突检测的载波侦听多路访问，广泛应用于无线网络。  &lt;br /&gt;
流程：连续侦听-&amp;gt; 帧间空间-&amp;gt; 竞争窗口-&amp;gt; 发送帧 -&amp;gt;超时。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;通道协议&lt;/h2&gt;
&lt;p&gt;FDMA、TDMA、CDMA 三种通道协议，移动电话系统比较常用。&lt;/p&gt;

&lt;h2 id=&quot;mac&quot;&gt;标准以太网MAC层帧结构&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;前导符preamble&lt;/th&gt;
      &lt;th&gt;SFD起始帧定界符&lt;/th&gt;
      &lt;th&gt;目的地址&lt;/th&gt;
      &lt;th&gt;源地址&lt;/th&gt;
      &lt;th&gt;长度或类型&lt;/th&gt;
      &lt;th&gt;数据字段&lt;/th&gt;
      &lt;th&gt;CRC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;7byte 56bit的01序列其实是物理层添加的&lt;/td&gt;
      &lt;td&gt;1byte&lt;/td&gt;
      &lt;td&gt;6byte&lt;/td&gt;
      &lt;td&gt;6byte&lt;/td&gt;
      &lt;td&gt;2byte&lt;/td&gt;
      &lt;td&gt;46byte~1500byte&lt;/td&gt;
      &lt;td&gt;4 byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-4&quot;&gt;关于帧长度限制&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;以太网对帧的最大最小长度有严格的限定，最小64byte是为了满足CSMA-CD正确运行的需要：  &lt;br /&gt;
64 byte: 46byte + 6 byte + 6 byte+2 byte+ 4 byte=46+18byte  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;时隙=往返时间+发送干扰序列所需时间   &lt;br /&gt;
在10Mbps的宽带上512 bits 发送时间t=51.2us。  &lt;br /&gt;
最大网络长度=2 * 10^8 * (51.2 * 10 ^(-6) /2 )=5120m。   &lt;br /&gt;
考虑中继器以及接收延时，理论值需要乘以48%，最大长度为2500m       &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最大帧长度为：1500+18=1518byte。 &lt;br /&gt;
设定最大值是为了：
    &lt;ul&gt;
      &lt;li&gt;一个站点独占共享介质&lt;/li&gt;
      &lt;li&gt;早期存储器昂贵，最大长度限制有助于减少缓冲器大小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;以太网的发展&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;网桥-&amp;gt;交换网&lt;/h3&gt;
&lt;p&gt;以太网发展的第一步是将局域网使用网桥分割，提高带宽、分割冲突域。
随后从桥接LAN扩展到交换以太网。  &lt;br /&gt;
在千兆以太网的全双工模式中不存在冲突的问题，电缆线长度取决于电缆线中信号的衰减程度。&lt;/p&gt;

&lt;p&gt;IEEE 802.3定义了第一代10Mbps 以太网的访问方法。   &lt;br /&gt;
     802.3u快速以太网数据传输速率100Mbps 全双工取消CSMA-CD  &lt;br /&gt;
     802.3z快速以太网数据传输速率1000Mbps 全双工取消CSMA-CD  &lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;千兆以太网拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/public/img/pic/1000mbpswangluo.png&quot; alt=&quot;tupo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;wifi&quot;&gt;wifi发展&lt;/h2&gt;

&lt;h2 id=&quot;section-8&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;Project 802 是用来被设计规范制造LAN以及不同LAN之间互联的标准。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Computer Network Overview</title>
        <link>https://gxnhxf.com/2016/05/12/network1.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/12/network1.html</guid>
        <pubDate>2016-05-12 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;计算机网络&lt;/h1&gt;

&lt;h2 id=&quot;osi-&quot;&gt;OSI 模型&lt;/h2&gt;
&lt;p&gt;open system interconnection ：开放互联模型   &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;各层次分布&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;应用层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;允许访问网络资源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表示层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;翻译加密和压缩数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;会话层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;建立管理和终止会话&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;传输层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提供端到端的可靠数据传输和差错纠正&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;网络层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;将分组从源地址传递到目的地址，提供互联&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数据链路层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;将位组成帧，提供点到点的传递&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;物理层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;介质传输位，提供机械及电器规范&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;tcpip&quot;&gt;TCP/IP协议簇&lt;/h2&gt;

&lt;p&gt;4层协议簇，因为TCP/IP协议簇的出现要比OSI早。
主要分为 主机到网络（物理层和数据链路层）、互联网层、传输层、应用层  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;TCP/IP协议栈&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;应用层：STMP FTP HTTP DNS SNMP TELNET&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;传输层：SCTP stream control transmission protocol TCP UDP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;网络层：IP ICMP IGMP ARP RARP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据链路层&amp;amp;物理层 主机到网络&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;网络层术语：&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;IP 网际协议，传输的是数据报，每个独立传输沿着不同的地址可能不同是到达，提供的是无连接状态&lt;br /&gt;
ARP address resolution protocol 地址解析协议&lt;br /&gt;
RARP 逆地址解析协议 reverse address resolution protocol&lt;br /&gt;
ICMP internet control message protocol &lt;br /&gt;
IGMP 用于将一个报文同时发送到一组接收者。  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tcpudp&quot;&gt;传输层 TCP/UDP&lt;/h2&gt;
&lt;p&gt;SCTP :流控制传输协议，对较新的应用提供支持，比如Internet的音频传输  &lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;关于寻址&lt;/h2&gt;
&lt;p&gt;不同层次的寻址方式是不同的，有4种地址类型：&lt;br /&gt;
1. 物理地址： 网络接口卡NIC上的唯一标识，通常所说的MAC地址&lt;br /&gt;
2. 逻辑地址： IP和其他协议地址&lt;br /&gt;
3. 端口地址： 传输层 TCP、UDP、SCTP &lt;br /&gt;
4. 专用地址： 进程面向应用的URL  一般格式是 IP:port   &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从一跳到另一条时，物理地址改变但是逻辑地址(ip)不改变，每次传递分组之前网络层需要寻找下一跳的物理地址，网络层查询路由表使用ARP发现物理地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;交换网络&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;交换网&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;特点&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;介绍&lt;/th&gt;
      &lt;th&gt;使用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;电路交换&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;资源使用率低，延迟较低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;流程：setup phrase-&amp;gt;data tarnsfer-&amp;gt; teardown phase ，需要建立连接和连接拆除的过程，采用FDM或者TDM来传输&lt;/td&gt;
      &lt;td&gt;物理层使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分组交换（数据报交换）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;效率相对较高，但是网络延迟较大&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分组形式进行数据传输，不保存连接状态，不同分组可能从不同的路径到达目的地，可能会失序&lt;/td&gt;
      &lt;td&gt;网络层使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分组交换（虚电路交换）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;—&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;结合了电路交换网络与数据报交换的特征，需要建立和拆除的过程&lt;/td&gt;
      &lt;td&gt;数据链路层使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;报文交换&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–&lt;/td&gt;
      &lt;td&gt;–&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;交换机结构 :
电路交换机：空分交换机、时分交换机 space/time division switching    &lt;br /&gt;
分组交换机结构： 有四个部分，输入端口、输出端口、路由处理器、交换结构。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;其他项&lt;/h2&gt;
&lt;p&gt;xDSL 是数据用户线路 还有 A/V/H/S    &lt;br /&gt;
电话线500kbps 就能满足语音通信的需求  &lt;/p&gt;

&lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&gt;  --&gt;
</description>
      </item>
    
      <item>
        <title>Learning</title>
        <link>https://gxnhxf.com/2016/05/09/helloworld.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/09/helloworld.html</guid>
        <pubDate>2016-05-09 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/question/28358499&quot;&gt;来自知乎&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;practice-makes-permanent&quot;&gt;Practice makes Permanent&lt;/h2&gt;

&lt;p&gt;专注和发散&lt;/p&gt;

&lt;p&gt;拖延-痛苦被激活&lt;/p&gt;

&lt;p&gt;记忆&lt;/p&gt;

&lt;p&gt;睡眠 休闲 运动&lt;/p&gt;

&lt;p&gt;番茄工作法减少拖延保持上时间精力集中&lt;/p&gt;

&lt;p&gt;Focus on process rather than product&lt;/p&gt;

&lt;p&gt;花时间和精力在你感觉最难的事情上&lt;/p&gt;

&lt;p&gt;另一个建议是做计划，weekly list of key tasks, and daily to-do list。每周对主要任务列个计划，每天再列个待办事项。
最难的事情先做
制定结束时间
遇到困难先进行尝试
如果踏踏实实但是很多人一样，一章一节的看完一本书，看完还不知所云，那就是在侮辱自己。不做自取其辱的事情。&lt;/p&gt;

&lt;p&gt;不要着急看文字；着重图表、案例、例题。&lt;/p&gt;

&lt;p&gt;操作：
身体能量补充：50分钟休息10分钟，可以运动俯卧撑、或者坚果。我吃山楂&lt;/p&gt;

&lt;p&gt;情绪能量补充：情绪疲劳厌倦，one way is relax. 听音乐&lt;/p&gt;

&lt;p&gt;不要过分透支学习能量：到了限定时间就结束，不然会导致自己觉得很疲劳，第二天不能坚持容易懈怠&lt;/p&gt;

&lt;p&gt;休息间隙：
休息间隙用牛逼的耳机听喜欢的音乐，是必要的工作；个人爱好，俯卧撑也是必要工作；&lt;/p&gt;

&lt;p&gt;在疲劳来临之前休息放松是最好的缓解疲劳的方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;推荐者万万众，实践者几人&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;概要图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/pic/learning.jpg&quot; alt=&quot;tupian&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;笔记&lt;/h2&gt;
&lt;p&gt;格式：如果你想到长期保持笔记效率，可以自己编一套格式。我的是：“标题，简要，重点，个人思考，相关内容截图，相关网页链接，难点，个人疑问，总结。”不一定适合所有人。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;小故事&lt;/h2&gt;
&lt;p&gt;我有个手残的朋友，小时候一起学过钢琴，然而现在6的不行，主要原因是他比较执着。当时班里不到十个人，这个人是弹的最差的。我们班后面是一中的操场，我们经常在那里侮辱他，因为旁边都是浪浪的大姐姐，我们出于正常的情感需要，自然就会找他麻烦。可现在，我已经不会弹了，班里的其他同学，比如老师的儿子，也弹的不咋地。这小子年复一年的练，别人练十遍，他就练一百遍，简直丧心病狂，是那种最讨厌的朋友。如果你有志在一个专业里走到巅峰，重复是唯一的方法。不要想着旁门左道，通过重复的基础练习，才是技艺飞升的法宝。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作者：路西法
链接：http://www.zhihu.com/question/28358499/answer/52319231
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;学习感想&lt;/h2&gt;
&lt;p&gt;过去，学习只是针对与教科书上的内容，而在现在这个网络发达信息无处不在的世界，学习不仅仅局限于此。过去我受过的教育，一直都在强调踏实努力重要性，对如何努力却提及甚少，所以过去我对于努力的重要性认识很充分无需加强这一点。 &lt;br /&gt;
时间，年少岁月，青葱易逝。二十又四的年纪不算太小,野蛮的努力，只相信勤奋相信时间是不够的了，时间不等人，如何高效率的才重要，不是要急于求成，而是专注高效。就如那句话说的，比如读书，如果像很多人一样踏踏实实把一本书看完，然后仍旧不知所云，那简直就是对自己的侮辱，自取其辱。少一些自取其辱，才能茁壮自己的信心，就如读大学有些人是把自己读坏了，不如不读，不求日有所增，只要面向前方，潜移默化循环向上。经历愈多，见识愈广，应该知道努力的重要性，更应该知道积累的重要性。不要急于求成是指不要着只盯着结果看，功皆为利；而是功是功利是利，功一定要大于利。&lt;br /&gt;
懒惰，懒惰的勤奋，兜兜转转不抓重点，要比什么都不做还要可憎，消磨时间不如娱乐。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>电影 《返老还童》</title>
        <link>https://gxnhxf.com/2016/05/07/the_curious_case_of_benjamin_button.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/07/the_curious_case_of_benjamin_button.html</guid>
        <pubDate>2016-05-07 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;h4 id=&quot;for-what-its-worth-its-never-too-late-or-in-my-case-too-early-to-be-whoever-you-want-to-be&quot;&gt;For what it’s worth, it’s never too late, or in my case, too early, to be whoever you want to be.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;theres-no-time-limit-stop-whenever-you-want&quot;&gt;There’s no time limit, stop whenever you want.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;you-can-change-or-stay-the-same&quot;&gt;You can change or stay the same.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;theres-no-rules-to-this-thing&quot;&gt;There’s no rules to this thing.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;we-can-make-the-best-or-the-worst-of-it&quot;&gt;We can make the best or the worst of it.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;i-hope-you-make-the-best-of-it&quot;&gt;I hope you make the best of it.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;i-hope-you-see-things-that-startle-you&quot;&gt;I hope you see things that startle you.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;i-hope-you-feel-things-you-never-felt-before&quot;&gt;I hope you feel things you never felt before.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;i-hope-you-meet-people-with-a-different-point-of-view&quot;&gt;I hope you meet people with a different point of view.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;i-hope-you-live-a-life-youre-proud-of&quot;&gt;I hope you live a life you’re proud of.&lt;/h4&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;if-you-find-that-you-are-not-i-hope-you-have-the-strength-to-start-all-over-again&quot;&gt;If you find that you are not, I hope you have the strength to start all over again.&lt;/h4&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>关于linux 进程</title>
        <link>https://gxnhxf.com/2016/05/07/linux_process.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/07/linux_process.html</guid>
        <pubDate>2016-05-07 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;linux&quot;&gt;linux进程&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;关于进程线程的概念推荐文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://buptjz.github.io/2014/04/23/processAndThreads&quot;&gt;进程、线程及其内存模型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangzhebjut/article/details/39034327&quot;&gt; Linux进程创建&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yusiguyuan/article/details/45155035&quot;&gt;Linux进程地址空间 &amp;amp;&amp;amp; 进程内存布局&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangzhebjut/article/details/39034327&quot;&gt;引用自&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
    0     1     1     1 ?           -1 Ss       0   0:01 /sbin/init
    0     2     0     0 ?           -1 S        0   0:00 [kthreadd]
    2     3     0     0 ?           -1 S        0   0:03 [ksoftirqd/0]
    2     5     0     0 ?           -1 S&amp;lt;       0   0:00 [kworker/0:0H]
    2     7     0     0 ?           -1 S        0   0:43 [rcu_sched]
    2     8     0     0 ?           -1 S        0   0:00 [rcu_bh]
    2     9     0     0 ?           -1 S        0   0:02 [migration/0]
    2    10     0     0 ?           -1 S        0   0:01 [watchdog/0]
    2    11     0     0 ?           -1 S        0   0:01 [watchdog/1]
    2    12     0     0 ?           -1 S        0   0:00 [migration/1]
    2    13     0     0 ?           -1 S        0   0:01 [ksoftirqd/1]
    2    15     0     0 ?           -1 S&amp;lt;       0   0:00 [kworker/1:0H]
    2    16     0     0 ?           -1 S        0   0:01 [watchdog/2]
    2    17     0     0 ?           -1 S        0   0:00 [migration/2]
    2    18     0     0 ?           -1 S        0   0:00 [ksoftirqd/2]
    2    20     0     0 ?           -1 S&amp;lt;       0   0:00 [kworker/2:0H]
    2    21     0     0 ?           -1 S        0   0:01 [watchdog/3]
    2    22     0     0 ?           -1 S        0   0:00 [migration/3]
    2    23     0     0 ?           -1 S        0   0:00 [ksoftirqd/3]
    2    25     0     0 ?           -1 S&amp;lt;       0   0:00 [kworker/3:0H]
    2    26     0     0 ?           -1 S&amp;lt;       0   0:00 [khelper]
    2    27     0     0 ?           -1 S        0   0:00 [kdevtmpfs]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;TPGID一栏写着-1的都是没有控制终端的进程，也就是守护进程。在COMMAND一列用[]括起来的名字表示内核线程，这些线程在内核里创建，没有用户空间代码，因此没有程序文件名和命令行，通常采用以k开头的名字，表示Kernel。init是祖先进程，守护进程通常采用以d结尾的名字，表示Daemon。&lt;/p&gt;

&lt;p&gt;附:由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能够突破这种限制，它从被执行开始运转，直到整个系统关闭时才退出。如果想让某个进程不因为用户或终端或其他地变化而受到影响，那么就必须把这个进程变成一个守护进程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;操作进程的工具&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;strace 打印一个程序和它的子进程调用的每个系统调用的轨迹。 用-static 编译一个程序，能够得到更清楚的轨迹&lt;/li&gt;
  &lt;li&gt;ps 列出系统中当前的进程（包括僵尸进程）&lt;/li&gt;
  &lt;li&gt;top 打印出关于当前进程的资源使用情况&lt;/li&gt;
  &lt;li&gt;kill 发送一个信号给进程。&lt;/li&gt;
  &lt;li&gt;/proc 一个虚拟文件系统，以ASCII文本格式输出大量内核数据的内容，用户程序可以读取。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;C
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;fcntl.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;
void handler();
int main(int argc,char* argv[],char*envp[])
{
 int i=0;
 printf(&quot;%s,%s\n&quot;,argv[0],argv[1]);
 return 0;
}
&lt;/code&gt;
strace test&lt;/p&gt;

&lt;p&gt;```C
execve(“/usr/bin/test”, [“test”], [/* 72 vars */]) = 0
brk(0)                                  = 0x8dfd000
access(“/etc/ld.so.nohwcap”, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb773d000
access(“/etc/ld.so.preload”, R_OK)      = -1 ENOENT (No such file or directory)
open(“/etc/ld.so.cache”, O_RDONLY|O_CLOEXEC) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=108559, …}) = 0
mmap2(NULL, 108559, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7722000
close(3)                                = 0
access(“/etc/ld.so.nohwcap”, F_OK)      = -1 ENOENT (No such file or directory)
open(“/lib/i386-linux-gnu/libc.so.6”, O_RDONLY|O_CLOEXEC) = 3
read(3, “\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\233\1\0004\0\0\0”…, 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1754876, …}) = 0
mmap2(NULL, 1759868, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7574000
mmap2(0xb771c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a8000) = 0xb771c000
mmap2(0xb771f000, 10876, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb771f000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7573000
set_thread_area({entry_number:-1 -&amp;gt; 6, base_addr:0xb7573940, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb771c000, 8192, PROT_READ)   = 0
mprotect(0x8050000, 4096, PROT_READ)    = 0
mprotect(0xb7760000, 4096, PROT_READ)   = 0
munmap(0xb7722000, 108559)              = 0
brk(0)                                  = 0x8dfd000
brk(0x8e1e000)                          = 0x8e1e000
open(“/usr/lib/locale/locale-archive”, O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=8752496, …}) = 0
mmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7373000
mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0x855000) = 0xb773c000
close(3)                                = 0
close(1)                                = 0
close(2)                                = 0
exit_group(1)                           = ?
+++ exited with 1 +++&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;!-- ## 进程 --&gt;
</description>
      </item>
    
      <item>
        <title>书单和阅读记录</title>
        <link>https://gxnhxf.com/2016/05/06/readingbooks.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/06/readingbooks.html</guid>
        <pubDate>2016-05-06 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;技术修炼&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;[ ] apue (unix 环境高级编程) 2016/8/26 2016/10/26 看完第一遍&lt;/li&gt;
  &lt;li&gt;[ ] unix网络编程(卷1) &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;apue &lt;a href=&quot;http://www.apuebook.com/code3e.html&quot;&gt;源码参考&lt;/a&gt;
尝试了解memcache、Lighttpd kernel source code&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;闲情逸致&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;[x] 《三体》 　　　   刘慈欣　　2016/9 ~ 2016/10&lt;/li&gt;
  &lt;li&gt;[ ] 《孤独六讲》    蒋勋&lt;/li&gt;
  &lt;li&gt;[ ] 《当我谈跑步时，我谈些什么》   村上春树&lt;/li&gt;
  &lt;li&gt;[ ] 《解忧杂货铺》　　　　　　　        东野圭吾&lt;/li&gt;
  &lt;li&gt;[ ] 《大数据时代》Viktor Mayer-Schonberger ,Kenneth Cukier&lt;/li&gt;
  &lt;li&gt;[ ] 《人类简史》　 尤瓦尔.赫拉利&lt;/li&gt;
  &lt;li&gt;[ ] 《》&lt;/li&gt;
  &lt;li&gt;[ ] 《》&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>深入理解计算机系统4</title>
        <link>https://gxnhxf.com/2016/05/06/cpp_note4.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/05/06/cpp_note4.html</guid>
        <pubDate>2016-05-06 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;第十章、虚拟存储器&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;需要理解的要点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;虚拟存储器与cpu寻址的关系&lt;/li&gt;
  &lt;li&gt;虚拟地址、各种地址转换&lt;/li&gt;
  &lt;li&gt;虚拟存储器和文件系统的关系&lt;/li&gt;
  &lt;li&gt;进程的地址空间&lt;/li&gt;
  &lt;li&gt;进程如何加载到内存中&lt;/li&gt;
  &lt;li&gt;进程之间的共享、共享库与虚拟存储器的关系&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangzhebjut/article/details/39060253&quot;&gt;文章写的不错&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/public/files/virtual_address_to_phycial_address.pdf&quot;&gt;virtual_address_to_phycial_address.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;虚拟存储器的作用&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作为缓存的工具&lt;/strong&gt;
 物理内存调入调出的单位是页，所以虚拟存储器的对应也是page，物理页面，被成为页帧page frame。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在任何时刻，虚拟页面的集合部分都分为三种。
 1. 未分配的 ：没有数据相关联，也没有和物理存储器上的相关页面有映射转换关系
 2. 缓存的   ：当前缓存在物理存储器中的已分配的页面
 3. 未缓存的 ：当前没有缓存在物理存储器中的已经分配页面 —— 例如存储器映射，将磁盘文件映射到虚拟内存但是并没有实际copy文件到物理内存中。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;作为存储器的管理工具&lt;/strong&gt;
 操作系统为每个进程创建了一个独立的页表，&lt;strong&gt;多个虚拟页面可以映射到同一个共享物理内存页面中&lt;/strong&gt;。按需页面调度和独立的虚拟地址空间的结合对系统中存储器的使用和管理造成了深远的影响，特别地，&lt;strong&gt;VM简化了，链接、加载、共享代码和数据，以及对应用分配存储器。&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;简化链接 
 文本区总是从虚拟地址0x08048000处开始…，因此这就允许简化了链接器的实现，允许链接器生成全链接的可执行文件，所以就解释了为什么linux中使用objdump工具获取elf文件的地址从0x08048000开始。&lt;/li&gt;
      &lt;li&gt;简化共享
 每个进程必须调用相同的操作系统内核代码，而每个c程序都会调用标准库中的程序，比如printf。&lt;strong&gt;操作系统通过将不同的进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个拷贝，&lt;/strong&gt;而不是在每个进程中都包含单独的内核和C标准库的拷贝。&lt;/li&gt;
      &lt;li&gt;简化存储分配
 当程序调用malloc分配堆空间时候，由于页表工作的方式，操作系统没必要分配K个连续的物理存储器页面。页面可以随机分散在物理存储器中。&lt;/li&gt;
      &lt;li&gt;简化加载
 虚拟存储器可以使得加载可执行文件和共性目标文件到存储器变得容易。elf可执行文件中的.data和.text节是相邻的，为了加载这些节到一个新创建的进程中，&lt;strong&gt;linux加载程序分配了一个从地址0x08048000处开始的连续虚拟页面区域，将他们标识为无效的（未缓存），并将他们的页表条目执行目标文件中适当的位置&lt;/strong&gt;。
 很重要的一点是，加载器从不磁盘中拷贝任何数据到存储器中，当每个页面第一次被引用时候虚拟存储器按需地自动将数据从磁盘调入到存储器。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;作为存储器保护的工具&lt;/strong&gt;
 实际的页表中为每个条目添加一些许可位，从而控制对一个虚拟页面访问。如果指令违反了这些许可条件，那么就会触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Unixshell典型地将这种一场报告为“段错误”，segmentataion fault。
## 地址翻译&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/pic/va_to_pa.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;地址翻译：也就是虚拟地址VA到物理地址PA的转换
名词解释：
MMU:memory management uint
VPN VPO: Virtual page number :Virtual page offset
PPN PPO: Physical page number:Physical page offset
TLB:
PDBR: page directory base register
PTBR: page table base register
PTE:  page table entry 页表条目
PDE:  page directory entry 页目录条目
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;地址构成&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;虚拟地址va的组成部分&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;VPO&lt;/td&gt;
      &lt;td&gt;虚拟地址页面偏移量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VPN&lt;/td&gt;
      &lt;td&gt;虚拟页号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TLBI&lt;/td&gt;
      &lt;td&gt;TLB索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TLBT&lt;/td&gt;
      &lt;td&gt;TLB标记&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;因为TLB采用全相连映像或者组相连 ，所以TLBI作为组的索引字段&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;物理地址PA组成部分&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PPO&lt;/td&gt;
      &lt;td&gt;物理地址页面偏移量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PPN&lt;/td&gt;
      &lt;td&gt;物理页号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CO&lt;/td&gt;
      &lt;td&gt;缓冲块内字节偏移量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CI&lt;/td&gt;
      &lt;td&gt;高速缓存索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CT&lt;/td&gt;
      &lt;td&gt;告诉缓存标记&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;由上表可以看出来由于物理内存在实际使用中为了进一步提高cpu访存速度，会在cpu和存储器之间加一个高速缓存SRAM，所以有作为高速缓存的映射字段CO CT CI&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;地址翻译过程&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;多级页表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/pic/pdbr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/pic/m_pages.png&quot; alt=&quot;&quot; /&gt; &lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;翻译过程&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;C
start：
    if(在TLB中查询到有对应的条目)
    {
        直接将对应条目PTE中抽取PPN与VPO合并为物理地址
    }
    else //TLB查询未能命中
    {
        if(页表查询命中)
        {
            从页表中取出PPN与VPO合并为物理地址
        }
        else//页表查询未命中
        {
            引发页面错误，页面换入；
            goto start;
        }
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如下图：
&lt;img src=&quot;/public/img/pic/translation.jpg&quot; alt=&quot;tupain&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;存储器映射&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;映射一个虚拟页面的结合到任意一个文件的任意位置的概念叫做存储器映射&lt;/strong&gt;。Unix提供了一个叫做mmap的系统调用，允许应用程序进行自己的存储器映射。&lt;/p&gt;

&lt;p&gt;注意这里的存储器映射是指将磁盘上的文件映射到进程的虚拟地址空间，当进程可以直接通过访问内存的方式访问一个文件，当然这里的映射实际并没有copy实际的文件到内存中，当进程访问文件时会发生缺页，此时文件才会被换入到内存区域中。&lt;strong&gt;（如上图的共享库和mmap内存映射区）&lt;/strong&gt; &lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一个进程的地址空间&lt;/h2&gt;
&lt;p&gt;一个进程的地址空间
&lt;img src=&quot;/public/img/pic/linux_process_address_space.png&quot; alt=&quot;processaddress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先要知道的是每个进程使用相同的存储器映像地址空间&lt;/strong&gt; 
从0xFFFFFFFF~0xBFFFFFFF为内核虚拟存储区 
从0xC0000000向下为用户栈区 从高地址向底地址生长 从0x40000000向上为共享库的存储器映射区 
从0x08048000向上为只读数据段开始位置 为.init .text .rodata 代码段和只读数据段;继续向上为.data .bss 为数据段 &lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;动态存储器分配&lt;/h2&gt;

&lt;p&gt;动态存储分配器维护着一个进程的虚拟存储器区域称为堆heap,在大多数的Unix系统中，堆是一个请求二进制零的区域，它紧接在未初始化的bss区域之后，并且向上生长。对于每个进程，内核维护一个变量brk，它指向堆的顶部。&lt;/p&gt;

&lt;p&gt;动态存储器通过隐式空闲链表来实现。任何实际的分配器都需要一些数据结构来允许它区分已经分配的块和空闲块，大多数分配器将这些信息嵌在块本身。
例如
一个简单的堆块的格式如下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;一个堆块&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;header&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;有效载荷&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;填充&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;footer&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;header部分为块的大小信息，因为可能涉及到对齐，例如分配时按照8字节对齐的话，header的最后三位为一直是0，所以可以释放剩余3位编码其他信息，例如取最后一位来标识块是已分配(1)还是空闲的(0) ,另外为了方便隐式空闲链表工作，回收已经被释放的块，如果一块的后边是可合并的那么容易办到直接扩展就行，但是如过是当前块的前边需要合并呢？单向链表是代价会是线性时间，所以这时候如果在块的尾部也追加一个header一样的尾标记那么就容易实现了&lt;/li&gt;
  &lt;li&gt;合并空闲块的时机也是需要考虑的事情 
    * 可以立即合并，一旦free就合并空闲块
    * 可以推迟合并，等到某个时刻之后进行合并，例如在找不到合适的块的时候进行空闲块的合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;swap-&quot;&gt;关于swap 分区&lt;/h2&gt;

&lt;h4 id=&quot;what-is-swap-from-herehttpshelpubuntucomcommunityswapfaqwhydoineedswap3f&quot;&gt;1. What is swap? &lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq#Why_do_I_need_swap.3F&quot;&gt;from here&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Swap space is the area on a hard disk which is part of the Virtual Memory of your machine, which is a combination of accessible physical memory (RAM) and the swap space. Swap space temporarily holds memory pages that are inactive. Swap space is used when your system decides that it needs physical memory for active processes and there is insufficient unused physical memory available. If the system happens to need more memory resources or space, inactive pages in physical memory are then moved to the swap space therefore freeing up that physical memory for other uses. Note that the access time for swap is slower therefore do not consider it to be a complete replacement for the physical memory. Swap space can be a dedicated swap partition (recommended), a swap file, or a combination of swap partitions and swap files.
swap空间在linux中被用于当物理内存(RAM)被耗尽时。当系统需要更多的内存资源而RAM已经满了，那么那些不被使用的页将会被替换到swap空间中。尽管swap分区对于RAM很小的机器很有用，但是，它不能够替代RAM，因为swap空间是外部磁盘空间，它要比物理内存慢很多很多。 (refer from &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ch-swapspace.html&quot;&gt;Here&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;swap&quot;&gt;2.  关于swap空间&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;swap空间：可以是一个专用的交换分区——也就是我们安装linux系统时候需要分配的swap分区（swap partion），也可是一个swap file，或者a combination of swap partion and swap files。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;swap-httpshelpubuntucomcommunityswapfaqwhydoineedswap3f&quot;&gt;3. swap分区的用处 &lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq#Why_do_I_need_swap.3F&quot;&gt;引用自&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Memory consuming programs&lt;/em&gt;&lt;/strong&gt; Sometimes, a large program (like LibreOffice, Neverwinter Nights, or a video editor) make the entire system need extra memory. A significant number of the pages used by these large programs during its startup may only be used for initialization and then never used again. The system can swap out those pages and free the memory for other programs or even for the disk cache. In these cases, swap will be used to help the system handle any extra load.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Hibernation (suspend-to-disk 系统挂起到硬盘)&lt;/strong&gt;  The hibernation feature &lt;strong&gt;休眠功能&lt;/strong&gt; (suspend-to-disk) writes out the contents of RAM to the swap partition before turning off the machine把RAM的内容暂存到swap中. Therefore, your swap partition should be at least as big as your RAM size. The hibernation implementation currently used in Ubuntu, swsusp, needs a swap or suspend partition. It cannot use a swap file on an active file system（ubuntu里边不能在主分区里用交换文件来完成挂起功能，必须使用交换分区或者暂存分区）.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Unforeseeable Circumstances不可预见的突发情况&lt;/em&gt;&lt;/strong&gt;  Unforeseeable events can and will happen (a program going crazy程序跑飞了, some action needing much more space than you thought, or any other unpredictable combination of events不可预料的事件). In these cases, swap can give you an extra delay to figure out what happened, or to finish what you are working on.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Optimizing memory usage 优化内存使用&lt;/em&gt;&lt;/strong&gt;  Since mechanical hard drives are considerably slower than RAM (SSD - Solid State Drive - storage is not as slow as physical drives, but still slower than RAM), when you need a file (be it a data file like a video, executables like Firefox, or libraries), the Linux kernel reads the file into RAM and keeps it there, so that the next time you need it, it is already in RAM and data access is much faster. The portions of RAM that accelerate disk read are called “cached memory.” You will notice that they make a huge difference in terms of responsiveness. &lt;strong&gt;The Linux kernel automatically moves RAM reserved by programs–but not really used–into swap, so that it can serve the better purpose of extending cached memory. linux内核自动的将RAM中被应用程序使用的保留的但是并没有实际使用的内存页面，放入到swap分区中，从而达到扩展内存的目的&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optimizing Swap performance Because swap space uses a disk device, this can cause performance issues in any system that uses swap space significantly because the system itself may also be using the same disk device at the same time that it is required for swap operations. One way to reduce this problem is to have swap space on a different physical drive so that the competition for that resource is either reduced or eliminated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;example-scenarios-&quot;&gt;Example Scenarios(交换分区的分配 举个栗子)&lt;/h3&gt;

&lt;p&gt;(last 3 columns denote swap space)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RAM(MB) No hibernation  With Hibernation  Maximum
     256     256              512               512
     512     512             1024              1024
    1024    1024             2048              2048

    RAM(GB) No hibernation  With Hibernation  Maximum
      1      1                2                   2
      2      1                3                   4
      3      2                5                   6
      4      2                6                   8
      5      2                7                  10
      6      2                8                  12
      8      3               11                  16
     12      3               15                  24
     16      4               20                  32
     24      5               29                  48
     32      6               38                  64
     64      8               72                 128
    128     11              139                 256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;【&lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq#Why_do_I_need_swap.3F&quot;&gt;修改系统交换分区参考这里&lt;/a&gt; 】       &lt;/p&gt;

&lt;h2 id=&quot;fork&quot;&gt;fork()函数&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;一个程序一旦调用fork函数，系统就为一个新的进程准备了前述三个段，
系统让新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。&lt;br /&gt;
fork()不仅创建出与父进程代码相同的子进程，而且父进程在fork执行点的所有上下文场景也被自动复制到子进程中，包括：&lt;br /&gt;
  ——&amp;gt;全局和局部变量&lt;br /&gt;
  ——&amp;gt;打开的文件句柄&lt;br /&gt;
  ——&amp;gt;共享内存、消息等同步对象&lt;br /&gt;
而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。现在，已经是两个进程了，对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;1&quot;&gt; --&gt;
</description>
      </item>
    
      <item>
        <title>深入理解计算机系统3</title>
        <link>https://gxnhxf.com/2016/04/20/cpp_note3.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/04/20/cpp_note3.html</guid>
        <pubDate>2016-04-20 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;第七章、链接过程&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ar ：创建静态库，插入、删除、列出和提取成员；&lt;/li&gt;
  &lt;li&gt;strings ：列出目标文件中所有可以打印的字符串；&lt;/li&gt;
  &lt;li&gt;strip ：从目标文件中删除符号表信息；&lt;/li&gt;
  &lt;li&gt;nm：列出目标文件符号表中定义的符号；&lt;/li&gt;
  &lt;li&gt;size ：列出目标文件中节的名字和大小；&lt;/li&gt;
  &lt;li&gt;readelf ：显示一个目标文件的完整结构，包括ELF 头中编码的所有信息。&lt;/li&gt;
  &lt;li&gt;objdump ：显示目标文件的所有信息，最有用的功能是反汇编.text节中的二进制指令。&lt;/li&gt;
  &lt;li&gt;ldd ：列出可执行文件在运行时需要的共享库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;httpsgithubcomhitatmhitatmgithubiotreemasterpublicfileslinkerandloader&quot;&gt;&lt;a href=&quot;https://github.com/Hitatm/Hitatm.github.io/tree/master/public/files/linkerandloader&quot;&gt;目标文件格式&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1 可重定位目标文件格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/public/img/pic/kechongdingwei.png&quot; alt=&quot;tupian&quot; /&gt; &lt;img src=&quot;/public/img/pic/kechongdingwei2.png&quot; alt=&quot;tupian&quot; /&gt;&lt;br /&gt;
###  2 可执行目标文件格式
   &lt;img src=&quot;/public/img/pic/kezhixingmubiaowenjian.png&quot; alt=&quot;tupian&quot; /&gt;
###  3 可执行目标文件的存储器映像
   &lt;img src=&quot;/public/img/pic/elf.png&quot; alt=&quot;tupian&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与.o文件稍有不同：&lt;/p&gt;

&lt;p&gt;ELF头中字段e-entry给出执行程序时第一条指令的地址，而在可重定位文件中，此字段为0
多一个.init节，用于定义_init函数，该函数用来进行可执行目标文件开始执行时的初始化工作
少两.rel节（无需重定位）
多一个程序头表，也称段头表（segment header table），是一个结构数组&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>电影 《怦然心动》</title>
        <link>https://gxnhxf.com/2016/04/20/Fipped.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/04/20/Fipped.html</guid>
        <pubDate>2016-04-20 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;哦&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>深入理解计算机系统2</title>
        <link>https://gxnhxf.com/2016/04/18/cpp_note2.html</link>
        <guid isPermaLink="true">https://gxnhxf.com/2016/04/18/cpp_note2.html</guid>
        <pubDate>2016-04-18 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;第5、6  、11章&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;第五章、优化程序性能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;减少过程调用
&lt;strong&gt;看上去无关紧要的过程调用再循环次数比较多的时候将会成为性能瓶颈。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C    
    for(i=0;i&amp;lt;strlen(ss);i++)
    and;
    len=strlen(ss);
    for(i=0;i&amp;lt;len;i++)
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;消除循环中的低效率，每次循环中没有改变的语句要放在循环之外  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消除不必要的存储器引用，例如 *dest+=5;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;关于编译器优化问题可以参考Muchnick的著作，这貌似是传说中最全面的&lt;/strong&gt;
 &lt;strong&gt;也可以参考Wadleigh 和 Crawford的关于软件优化的著作。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;第六章、优化程序性能(略读)&lt;/h2&gt;
&lt;p&gt;RAM Random-access memory 随机访问存储器 分为两类动态的和静态的。 SRAM6晶体管速度快抗干扰能力强，无需刷新，DRMA抗干扰不行，易失需要定时刷新。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;io&quot;&gt;第十一章、系统级I/O&lt;/h2&gt;

&lt;p&gt;底层IO包括 read write open close等接口
然后RIO    使用底层系统级IO 构建的适合网络读写的IO&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件分为普通文件、目录文件、套接字
    &lt;ul&gt;
      &lt;li&gt;目录文件其实就是包含其他文件信息的文件&lt;/li&gt;
      &lt;li&gt;套接字文件 用来通过网络与其他进程通信的文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件描述符：每个文件都有一个独立的文件描述符表，表项是由进程打开的文件描述符索引。每个打开的描述符表项指向文件表中的一个表项。&lt;/li&gt;
  &lt;li&gt;文件表：&lt;strong&gt;所有进程共享&lt;/strong&gt;文件表，即打开文件的集合，文件表表项中包括文件的位置，&lt;strong&gt;引用计数&lt;/strong&gt;(即当指向该文件的描述符个数)，以及&lt;strong&gt;一个执行V-node表中对应项的指针&lt;/strong&gt;。
关闭一个文件内核不会删除该文件表表项，直到文件表的引用计算数为0，才会删除。&lt;/li&gt;
  &lt;li&gt;v-node 表：和文件表一样，所有进程共享。&lt;a href=&quot;https://github.com/torvalds/linux/tree/master/fs&quot;&gt;(linux文件系统)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;C
typedef struct vnode {
  kmutex_t        v_lock;                 /* protects vnode fields */
  u_short         v_flag;                 /* vnode flags (see below) */
  u_long          v_count;                /* reference count */
  struct vfs      *v_vfsmountedhere;      /* ptr to vfs mounted here */
  struct vnodeops *v_op;                  /* vnode operations */
  struct vfs      *v_vfsp;                /* ptr to containing VFS */
  struct stdata   *v_stream;              /* associated stream */
  struct page     *v_pages;               /* vnode pages list */
  enum vtype      v_type;                 /* vnode type */
  dev_t           v_rdev;                 /* device (VCHR, VBLK) */
  caddr_t         v_data;                 /* private data for fs */
  struct filock   *v_filocks;             /* ptr to filock list */
  kcondvar_t      v_cv;                   /* synchronize locking */
} vnode_t;
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://everything2.com/title/vnode&quot;&gt;vnode&lt;/a&gt; (“virtual node”)仅在文件打开的时候，才出现的；
而inode定位文件在磁盘的位置，它的信息本身是存储在磁盘等上的，当打开文件的时候从磁盘上读入内存。&lt;a href=&quot;http://blog.csdn.net/jnu_simba/article/details/8806654&quot;&gt;&lt;em&gt;from here&lt;/em&gt;&lt;/a&gt;
&lt;a href=&quot;http://img.my.csdn.net/uploads/201304/15/1366041111_3148.png&quot;&gt;图示如下&lt;/a&gt; &lt;img src=&quot;/public/img/pic/filedescriptor.png&quot; alt=&quot;tupina&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- 
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1&quot;&gt; --&gt;
</description>
      </item>
    
  </channel>
</rss>