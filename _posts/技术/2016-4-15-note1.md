---
layout: post
title: 深入理解计算机系统1
category: 技术
tags: 深入理解计算机系统
keywords: 
description: 没什么
---

[TOC]

# 第一章、深入理解计算机系统

## Hello.c的存储
* 系统中所有的信息-包括磁盘文件、存储器中的程序、存储器中放的用户数据以及网络上传输的数据都是由一串比特表示的。因此写一个helloworld程序的c文件的所有字符都是ascii存储的，包括所有的空格、回车、以及tab。

## Hello.c的编译过程

[这个过程更详细](http://blog.sciencenet.cn/blog-588243-638056.html)

![tupian](http://img1.51cto.com/attachment/201309/224935190.jpg)

* hello world的执行、编译的过程  （gcc -o hello hello.c） 
    * 预处理（cpp预处理器）根据以#开头的命令修改原始的c程序 例如#include<stdio.h> 将会读取系统头文件中的stdio.h并直接插入到程序文本中。生成.i文件
    * 编译 （ccl编译器）将程序文件翻译成汇编语言程序。生成.s 文件
    * 汇编  （as汇编器）将汇编代码翻译成机器指令，把这些指令打包成为一种 可重定位目标程序的格式 。生成.o文件
    * 链接 （ld链接器）hello程序中调用了printf函数，printf函数存在于一个单独的printf.o 目标文件中；链接器负责把hello.o和printf.o 合并到一起。生成hello文件
##hello的运行(未完成)
* 线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。线程之间的切换比进程更有优势，因为线程之间更容易共享数据，所以线程一般比进程更高效。
* 内存分布情况


    | **内存分布**|
    | ---------- |
    |  内核虚拟存储器   （Linux最上边的1/4的地址空间预留给操作系统中的代码和数据 [第10章介绍](#)|
    |   用户栈（运行时创建；编译器用来实现函数调用）[第3章](#)|
    | ...|
    |共享库的存储区域（存放像c标准库和数学库这样的共享库代码和数据的区域）[第7章介绍](#)|
    |...|
    |运行时堆 （malloc创建）[第10章介绍](#)|
    |读写数据        (从hello文件中加载进来的)|
    |只读的代码和数据(从hello文件中加载进来的)|
    |未用|

--------------------------------------------------
* 一个程序执行过程 来自[这里](http://tech.meituan.com/linker.html)

![一个程序执行过程](http://tech.meituan.com/img/linker/1.jpg)

--------

# 第二章、信息的表示和处理
## 信息的表示、整数的表示、运算
1. bit——位的概念；进制的转换；字的概念；
2. 寻址和字节顺序问题，争端的“端git”原来是 “争的是大端和小端”  o(∩_∩)o 
3. 为什么C字符串没有大端小端的问题，因为大小端是针对一个数据类型内部来说的，char型字符一般只有1个字节所以也就无大小端的问题了，但是**Java中是使用Unicode（统一字符编码标准）来表示字符串，使用Java字符流解析过程中如果有什么问题或许需要考虑下这个问题**。
4. 近世代数中环的概念是布尔代数的数学基础。
5. 展示下异或“^” 环的牛逼用处
    - 首先“^”的特点：
        + **a ⊕ a = 0**
        + a ⊕ b = b ⊕ a      交换律
        + **a ⊕b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c; 结合律**
        + **d = a ⊕ b ⊕ c 可以推出 a = d ⊕ b ⊕ c.**
        + **a ⊕ b ⊕ a = b. 牛逼之处**
    - 然后来段代码 使用“^”的奇技淫巧

``` C
        void swap(int * x ,int *y )
        {
			//notice!! if ADDRESS of x is same with y ;^ will  set the value to 0;
			if(x!=y)
		    {
            *x = *x ^ *y  ;// x=x^y
            *y = *x ^ *y  ;// y=x^y^y       => x
            *x = *x ^ *y  ;// x=x^y ^ x^y^y => y
			}
        }  
```

6. c语言中的“>> and <<” 移位运算从左到右结合，所以 **x<<j<<k == (x<<j)<<k**;
7. 注意强制类型转换时候发生的**截断**情况;
     由于c语言的强制类型转化产生程序员`无法预测的错误`，慎重使用！

``` C
     int x=21341234; 
     short sx =(short)x;
```

8. 位运算小技巧 
    *  x*7 =(x<<3) -x   ;
    *  -x = ~x+1        ;
    *  0xFF = (1<<8)-1  ;
9. NOTICE ! 必须十分小心的使用浮点数，因为浮点数的运算范围和精度有限，而且浮点数**不一定遵循普遍的运算律**，比如结合律。

--------

# 第三章、程序的机器级表示

>本章能够解答的问题：

* 如何用c编译器生成IA32汇编语言。
* 不同的控制结构生成的基本指令模式。例如条件、循环、开关语句
* 栈的分配、寄存器的使用、参数传递。
* 不同数据结构，如结构体、联合、数组的分配和访问方式。
* 指针的使用。

#Intel 系列处理器的发展
8086->80286->i386(体系结构扩展到32bit)->i486->Pentium系列
Intel指令集称为IA32指令集。 x86系列
**NOTICE**:gcc编译器是可以选择优化级别的。例如 gcc -O2 是告诉编译器使用第二级编译优化。

#gcc编译选项

|编译选项|-E|-S|-c|-o|
|:------|:----|:------|:----|:----|
|gcc |预编译插入宏替换|生成汇编文件 .s|编译生成目标文件 二进制格式 .o|链接生成可执行文件|

------------------------------

>中间代码分析：
>objdump -d -xxx.o 可以反汇编二进制文件以汇编语言形式展示。 objdump是目标文件阅读器。(**GDB有很多特性可以用来分析机器级别程序**)
>关于大端小端：大端高byte在前位于 **低地址** ；小端高byte在后位于 **高地址**。

#C语言循环语句的汇编级实现
* do {...} while()

```C
    loop: 
         body-statement;
         t=test-expr;
         if(t)
            goto loop;
```

* while(){...}

```C
    t=test-expr;
    if(!t)
        goto done;
-----------------------------
    loop: 
        body-statement;
        t=test-expr;
        if(t)
            goto loop; 
```

* for(;;;){...}
```C
    init-expr;
-----------------------------
    t=test-expr;
    if(!t)
        goto done;
-----------------------------
    loop: 
        body-statement;
        t=test-expr;
        if(t)
            goto loop; 
```

汇编级别的最终实现其实说明了，for do...while 和while循环的本质还是一样的，只不过实现时候循环之前的条件判断部分有不同。

* switch(x) 开关语句，其实通过实现一个跳转表来根据不同的条件x来实现跳转。

# 过程调用 
* 一个过程调用包括将数据(参数和返回值)和控制 从代码的一部分传递到另一部分。
另外在进入过程时为过程的局部变量分配空间，并在退出时释放这些空间。

* *大多数机器包括IA32*，只提供简单转移控制 **到过程**和 **从过程中转移出**的指令。
* **数据传递、局部变量的分配和释放通过操纵程序栈来实现**。

* **栈指针esp和帧指针ebp**,当程序执行过程中栈指针是可以移动的，因此大多数信息的访问都是相对于帧指针的。 
* 过程调用的栈结构 
    |stack|
    |------      | 
    |*此处一下为调用者的帧*|
    |param n     |
    |param n-1   |
    |....        |
    |param 1     |
    |返回值地址  |
    |**被保存的%ebp** *此处以下为被调用者的帧*|
    |被保存的寄存器，本地变量，临时变量|
    |参数构造区域|
    |**此处是栈顶**  【esp指向栈顶】|

# 嵌套数据类型

## 数组
程序需要根据数据的下标来计算元素所在的地址。按照行优先的来计算。
## 异类数据结构
Union 和 Struct

## 关于对齐 alignment
## 关于指针
>* int (*arr)[13] 指向int[13]的数组指针 ; int *arr[13] 内容为int指针的，指针数组。
>* void (\*f) (void \*)f为函数指针; void \*f(void\*) f为返回值为void* 型的函数。












































