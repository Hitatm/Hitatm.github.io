---
layout: post
title: leetcode 题目总结
category: Tech
tags: leetcode
keywords:
description: code
---

# 线性表部分
## 数组、向量
### 1. 有序数组删除重复的元素
使用一个index=0记录，遍历数组当数组遇到不同的放入array\[index++\]之中。
### 2. 有序数组如果有重复允许重复最多k次
使用一个变量来记录重复的次数
### 3. 查找循环移位的有序数组中的某个数（其中不存在重复的数） 要求O(logn)
二分查找 不过查找的前后边界需要做简单处理，分为一下2种情况
head |—————————————mid———————>|——————>| tail
head |———————>|————mid———————————————>| tail
可以根据head和mid之间的关系来判断数组移动是以上两种情况的哪一种。
例如对于第一种情况
如果head<=val<mid 则在\[head,mid\]之间查找,否则在\[mid ,tail\]之间找
对于第二种情况
如果mid<val<=tail 则在\[mid,tail\]之间查找，否则在\[head,mid\]之间找

### 4. 查找循环移位的有序数组中的某个数（其中存在重复的数字）
因为存在相同元素，则不能简单的判断head mid tail 的值大小就决定递增顺序，
此时有个简便的方法，当head==mid时候，此时遇到重复，让head继续向前移动既只考察\[head+1,tail\]之间，继续使用 \(3\)中的方法。

### 5. 给定两个已经排序好的数组长度分别为m n，找到两者所有元素中第k大的元素 代价O(log(m+n))
方法1： 其实直接merge两个数组merge到第k个的时候就结束，代价也不算大，时间O(k) 空间O(k)而已。
方法2： 可以折半查找，连个数组分别是 A\[0:m\]  B\[0:n\]分别找到其[k/2]的元素进行比较
如果a>b 则第k大元素在A[0:k/2]和B[k/2+1:n]之间的第k/2大的元素，可以排除掉k/2个元素
如果a<b 同理在A[k/2:m]和B[0,k/2]之间的第k/2大的元素。
如果a==b 那么返回此时的值即是第k大的元素。
### 6. 给定一串数组整数，查找最长递增序列的长度。

### 7. two sum 给一个数组一个值target 查找数组中的两个数，其和等于target，返回下标。假设解唯一
不能排序，因为返回值的是下标
暴力方法 O(n^2)
哈希表方法，map<int,int>mapp ,mapp\[值\]=下标 复杂度O(n)

### 8. 对于多个数求和等于某个值的一般都采用先排序然后左右夹逼的方法。

### 9. 删除一个数组中所有的有重复的元素一个不留，方法类似 (1.)

### 10. 积水问题
[如图](http://img.blog.csdn.net/20131204125216281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2VuZGVuMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
方法1：找到最高的柱子，然后依次从两边到中间对每个柱子进行计算，peak记录遍历过程中的最大的，然后每次将自己与peak比较如果小于peak那么水量增加peak-自身值。
方法2：遍历3次数组，前两次找到当前柱子i的左右两侧的最大值和最小值，第三次计算每个柱子上的积水量大小。
### 11. Rotate Image 旋转照片，二维数组表示照片，旋转90度
方法：
      1 2     4 1  变换方法:做沿着反对角线翻转，然后沿着中间翻转1 2    3 2    4 1
      4 3 =>  3 2                                         4 3 => 4 1 => 3 2

### 12. 大数加法 2.1.17
用vector每个元素表示一位 反转用法 rbegin(),注意最后进位。
### 13. 爬梯子 2.1.18
爬梯子，每次只能爬1个或者2个台阶，如果n个台阶有几种爬法。
f(n)=f(n-1)+f(n-2) 斐波那契数列
O(1)的方法是 使用斐波那契数列的通项公式，××××××××××××××××××××××××××××××××××××××× 使用方法。
### 14. 格雷码
格雷码的每个数和起前后连续两个数分别只有一位不同，格雷码和普通二进制码的转换，Grey=N^(N/2)
**另外 N&(N-1)表示的是N的二进制将最低位的1变为0的数值。**
### 15. Set Matrix Zeros
二维数组，如果某行某列的数值为0，那么将其对应行列都设置为0，返回处理后的矩阵。
方法1：m×n的矩阵使用 两个长为m，n的数组记录行是否需要标示为0 列是否标示为0.
方法2：常数空间，使用第一行、第一列来记录最后利用第一行第一列的数值，来处理整个矩阵
### 16. 分糖果问题
一排小孩，每个孩子至少一个糖果，年龄大的要比年龄小的多
使用一个数组来记录每个小孩的糖果数目
头到尾扫描一遍，遇到递增则在上一个基础上增加一个，遇到比前一个小的则在将其变为1个。
### 17. Single Number
找单独数字，一列数中只有一个数字只出现一次，其余均为两次，找出此数字
方法 使用"^" 位运算。
### 18. Single Number 2
类似于 17中，此时其余数字均出现三次，那么需要找出此数字。
可以模拟位的三进制，某个位上出现三那么将其置为0;
可以设置一个长为n的数组，记录每个位置出现的1的次数，如果是3的倍数将其之为零

## 链表
单链表
```C++
    struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x):val(x),next(nullptr){ };
    };
```
### 1. 大数加法
尾部对齐，注意最后的进位
### 2. Reverse List 反转链表
头插法
### 3. 链表去重，类似数组删除重复元素
可以采用递归，只需要处理头部第一个，如果相同删除，再迭代处理
### 4. Rotate List
给定一个k 将list循环移动k步
首先遍历整个list获取中的list长度len，在此过程中将链表的尾部和头部连接，然后将链表头移动len-k个位置，断开链表。
注意点：注意当k如果大于len需要考虑，k=k%len；
### 5. Remove Nth Node from end of List
定长的问题就是用定长距离指针，一个指针先走N步，然后两个同时走，从而后走的指针能找到倒数第N个的前一个元素，然后执行删除操作即可。
### 6. Reverse Nodes in K-groups    <implement>
每k个nodes 进行反转，最后如果不足k个不反转。
**递归求解子问题: 先处理前k个然后后边作为一个整体递归处理**
### 7. 判断一个链表是否有环
一个快指针一个慢指针，快指针每次走两步，慢指针一次一步。快的最后追上慢的说明有环形。
### 8. 链表有环 找环的起始位置
类似于 7 中
假设环的长度为r、链表头到环起始位置长度为l
当7中快慢指针相遇的时候走的距离分别为s、2s
t为相遇的位置距离入口的长度。
此时有：

 s =l+t
2s =l+n*r+t     => s= n*r =l + t => l= n*r - t;
也就是说 如果在快慢指针相遇的时候在链表头部再放一个慢指针，那么两个慢指针同时向前走，一定能够在环的入口相遇。

# 字符串
### 1. 字串问题，KMP算法
### 2. String to integer
需要考虑到string的范围 如果超过integer那么需要特别处理 例如设置
INT_MAX = 2147483647 INT_MIN = -2147483648
超出最大最小的范围将其设置为最大最小值。
另外需要考虑的是'+'、'-'符号问题
### 3. 最大回文字串问题？

# 栈和队列相关的问题需要找几个典型的问题

# 查找和排序问题
